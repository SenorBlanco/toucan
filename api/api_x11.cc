// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <dlfcn.h>
#include <sys/time.h>

#include <cassert>
#include <cstring>
#include <memory>

#define Window XWindow
#include <X11/Xlib-xcb.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/extensions/Xv.h>
#undef Window
#undef Success
#undef Always
#undef None
#undef Bool

#include <dawn/dawn_proc.h>
#include <dawn/native/DawnNative.h>
#include <dawn/native/VulkanBackend.h>
#include <vulkan/vulkan.h>
#include <vulkan/vulkan_xcb.h>
#include <webgpu/webgpu_cpp.h>

#include "api_internal.h"

namespace Toucan {

namespace {
int ToToucanEventModifiers(int state) {
  int result = 0;
  if (state & ShiftMask) { result |= Shift; }
  if (state & ControlMask) { result |= Control; }
  return result;
}
}  // namespace

static std::unique_ptr<dawn::native::Instance> gNativeInstance;
static wgpu::Instance                          gInstance;
static int                                     gNumWindows = 0;
static Atom                                    gWM_DELETE_WINDOW;

// FIXME: refactor this
wgpu::Device createDevice(wgpu::BackendType type) {
  if (!gNativeInstance) {
    gNativeInstance = std::make_unique<dawn::native::Instance>();
    DawnProcTable backendProcs = dawn::native::GetProcs();
    dawnProcSetProcs(&backendProcs);
  }

  if (!gInstance) {
    wgpu::InstanceDescriptor desc;
    gInstance = wgpu::CreateInstance(&desc);
  }

  for (auto adapter : gNativeInstance->EnumerateAdapters()) {
    wgpu::AdapterProperties properties;
    adapter.GetProperties(&properties);
    if (properties.backendType == type) { return adapter.CreateDevice(); }
  }
  return nullptr;
}

struct Window {
  Window(Display* dpy, XWindow w, VkSurfaceKHR vs, Device* d, wgpu::Surface s)
      : display(dpy), window(w), vkSurface(vs), device(d), surface(s) {}
  Display*      display;
  XWindow       window;
  VkSurfaceKHR  vkSurface;
  Device*       device;
  wgpu::Surface surface;
};

static Display* gDisplay;

Window* Window_Window(Device* device, int32_t x, int32_t y, uint32_t width, uint32_t height) {
  if (!gDisplay) gDisplay = ::XOpenDisplay(0);
  if (!gDisplay) return nullptr;
  XWindow     rootWindow = RootWindow(gDisplay, DefaultScreen(gDisplay));
  XVisualInfo visualInfo;
  if (!XMatchVisualInfo(gDisplay, DefaultScreen(gDisplay), 24, TrueColor, &visualInfo)) {
    return nullptr;
  }
  Colormap colorMap = ::XCreateColormap(gDisplay, rootWindow, visualInfo.visual, AllocNone);

  XSetWindowAttributes windowAttributes;
  windowAttributes.border_pixel = BlackPixel(gDisplay, visualInfo.screen);
  windowAttributes.colormap = colorMap;
  windowAttributes.event_mask = StructureNotifyMask;
  XWindow window = ::XCreateWindow(gDisplay, rootWindow, x, y, width, height, 1, /* border_width */
                                   visualInfo.depth, InputOutput, visualInfo.visual,
                                   CWColormap | CWEventMask, &windowAttributes);
  if (!window) { return nullptr; }
  Window* w = nullptr;
  void*   vkLib = dlopen("libvulkan.so.1", RTLD_NOW);
  if (!vkLib) { return nullptr; }
  auto createXcbSurfaceKHR =
      reinterpret_cast<PFN_vkCreateXcbSurfaceKHR>(dlsym(vkLib, "vkCreateXcbSurfaceKHR"));
  if (!createXcbSurfaceKHR) { return nullptr; }

  VkInstance vkInstance = dawn::native::vulkan::GetInstance(device->device.Get());
  if (!vkInstance) { return nullptr; }

  VkXcbSurfaceCreateInfoKHR surfaceCreateInfo;
  memset(&surfaceCreateInfo, 0, sizeof(VkXcbSurfaceCreateInfoKHR));
  surfaceCreateInfo.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
  surfaceCreateInfo.pNext = nullptr;
  surfaceCreateInfo.flags = 0;
  surfaceCreateInfo.connection = XGetXCBConnection(gDisplay);
  surfaceCreateInfo.window = window;

  VkSurfaceKHR vkSurface;
  if (createXcbSurfaceKHR(vkInstance, &surfaceCreateInfo, nullptr, &vkSurface) != VK_SUCCESS) {
    return nullptr;
  }
  XSelectInput(
      gDisplay, window,
      ButtonPressMask | ButtonReleaseMask | ButtonMotionMask | PointerMotionMask | ExposureMask);
  if (!gWM_DELETE_WINDOW) { gWM_DELETE_WINDOW = XInternAtom(gDisplay, "WM_DELETE_WINDOW", False); }
  ::XSetWMProtocols(gDisplay, window, &gWM_DELETE_WINDOW, 1);
  ::XMapWindow(gDisplay, window);
  ::XSync(gDisplay, True);
  wgpu::SurfaceDescriptorFromXlibWindow xlibDesc;
  xlibDesc.display = gDisplay;
  xlibDesc.window = window;
  wgpu::SurfaceDescriptor desc;
  desc.nextInChain = &xlibDesc;
  wgpu::Surface surface = gInstance.CreateSurface(&desc);
  gNumWindows++;
  return new Window(gDisplay, window, vkSurface, device, surface);
}

void Window_Destroy(Window* This) {
  XDestroyWindow(gDisplay, This->window);
  delete This;
}

static void PrintDeviceError(WGPUErrorType, const char* message, void*) {
  printf("Device error: %s\n", message);
}

Device* Device_Device() {
  wgpu::Device device = createDevice(wgpu::BackendType::Vulkan);
  if (!device) { return nullptr; }
  assert(dawn::native::vulkan::GetInstance(device.Get()));
  // TODO: add an error callback/interface to Toucan's Device.
  device.SetUncapturedErrorCallback(PrintDeviceError, nullptr);
  return new Device(device);
}

bool System_IsRunning() { return gNumWindows > 0; }

bool System_HasPendingEvents() { return XPending(gDisplay) != 0; }

Event* System_GetNextEvent() {
  if (!gDisplay) return nullptr;
  Event* result = new Event();
  result->type = EventType::Unknown;
  XEvent event;
  ::XNextEvent(gDisplay, &event);
  switch (event.type) {
    case ButtonPress:
    case ButtonRelease:
      result->type = event.type == ButtonPress ? EventType::MouseDown : EventType::MouseUp;
      result->button = event.xbutton.button;
      result->mousePos[0] = event.xbutton.x;
      result->mousePos[1] = event.xbutton.y;
      result->modifiers = ToToucanEventModifiers(event.xbutton.state);
      break;
    case MotionNotify:
      result->type = EventType::MouseMove;
      result->mousePos[0] = event.xmotion.x;
      result->mousePos[1] = event.xmotion.y;
      result->modifiers = ToToucanEventModifiers(event.xmotion.state);
      break;
    case DestroyNotify: gNumWindows--; break;
    case ClientMessage:
      if (static_cast<Atom>(event.xclient.data.l[0]) == gWM_DELETE_WINDOW) {
        ::XDestroyWindow(gDisplay, event.xclient.window);
        gNumWindows--;
      }
      break;
    default: break;
  }
  return result;
}

wgpu::TextureFormat GetPreferredSwapChainFormat() {
  return wgpu::TextureFormat::BGRA8Unorm;
}

SwapChain* SwapChain_SwapChain(int qualifiers, Type* format, Window* window) {
  Device*                   device = window->device;
  wgpu::SwapChainDescriptor desc;
  desc.usage = wgpu::TextureUsage::RenderAttachment;
  desc.format = wgpu::TextureFormat::BGRA8Unorm;
  XWindowAttributes attributes;
  XGetWindowAttributes(gDisplay, window->window, &attributes);
  desc.width = attributes.width;
  desc.height = attributes.height;
  desc.presentMode = wgpu::PresentMode::Immediate;
  wgpu::SwapChain swapChain = device->device.CreateSwapChain(window->surface, &desc);
  return new SwapChain(swapChain, {desc.width, desc.height, 1}, desc.format, nullptr);
}

double System_GetCurrentTime() {
  struct timeval now;

  gettimeofday(&now, NULL);
  return static_cast<double>(now.tv_sec) + static_cast<double>(now.tv_usec) / 1000000.0;
}

};  // namespace Toucan
