// Copyright 2025 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <sys/time.h>

#include <list>
#include <memory>
#include <os/log.h>

#include <webgpu/webgpu_cpp.h>

#import <UIKit/UIKit.h>
#import <Metal/Metal.h>
#import <MetalKit/MetalKit.h>

#include "api_internal.h"

@interface ToucanViewController : UIViewController
@end

@interface ToucanSceneDelegate : UIResponder <UIWindowSceneDelegate>
@property (strong, nonatomic) UIWindow* window;
@end

static int                        gNumWindows = 0;
static std::list<Toucan::Event*>  gEventQueue;

namespace Toucan {

static bool                                    gInitialized = false;

struct Window {
  Window(UIView*       v,
         id<MTLDevice> md,
         const uint32_t      sz[2])
      : view(v), mtlDevice(md) { size[0] = sz[0]; size[1] = sz[1]; }
  UIView*       view;
  id<MTLDevice> mtlDevice;
  uint32_t      size[2];
};

namespace {

uint32_t ToToucanEventModifiers(UIKeyModifierFlags modifiers) {
  uint32_t result = 0;
  if (modifiers & UIKeyModifierShift) { result |= static_cast<uint32_t>(EventModifiers::Shift); }
  if (modifiers & UIKeyModifierControl) { result |= static_cast<uint32_t>(EventModifiers::Control); }
  return result;
}

void Initialize() {
  UIApplication* app = [UIApplication sharedApplication];
}

}  // namespace

const uint32_t* Window_GetSize(Window* This) {
  return This->size;
}

Window* Window_Window(const uint32_t* size, const int32_t* position) {
  if (gNumWindows == 0) {
  }
  UIApplication* app = [UIApplication sharedApplication];

  id<MTLDevice> mtlDevice = MTLCreateSystemDefaultDevice();

  MTKView* view = [[MTKView alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
  [view setDevice:mtlDevice];
  [view setBackgroundColor:[UIColor blackColor]];
  Window*       w = new Window(view, mtlDevice, size);
  return w;
}

void Window_Destroy(Window* This) { delete This; }

wgpu::TextureFormat GetPreferredPixelFormat() {
  return wgpu::TextureFormat::RGBA8Unorm;
}

SwapChain* SwapChain_SwapChain(int qualifiers, Type* format, Device* device, Window* window) {
  wgpu::SurfaceConfiguration config;
  config.device = device->device;
  config.format = ToDawnTextureFormat(format);

  config.width = window->size[0];
  config.height = window->size[1];
  config.presentMode = wgpu::PresentMode::Fifo;

  wgpu::SurfaceDescriptorFromMetalLayer metalLayerDesc;
//  metalLayerDesc.layer = window->layer;
  wgpu::SurfaceDescriptor desc;
  desc.nextInChain = &metalLayerDesc;
  static wgpu::Instance instance = wgpu::CreateInstance({});
  wgpu::Surface surface = instance.CreateSurface(&desc);

  surface.Configure(&config);

  return new SwapChain(surface, device->device, {config.width, config.height, 1}, config.format, [[NSAutoreleasePool alloc] init]);
}

void SwapChain_Present(SwapChain* swapChain) {
  swapChain->surface.Present();
  [static_cast<NSAutoreleasePool*>(swapChain->pool) release];
  swapChain->pool = [[NSAutoreleasePool alloc] init];
}

void SwapChain_Destroy(SwapChain* This) {
  [static_cast<NSAutoreleasePool*>(This->pool) release];
  delete This;
}

Device* Device_Device() {
  wgpu::DeviceDescriptor desc;
  desc.SetUncapturedErrorCallback(
    [](const wgpu::Device&, wgpu::ErrorType type, wgpu::StringView message) {
      fprintf(stderr, "WebGPU Error:\n%s\n", message.data);
    }
  );

  wgpu::Device device = CreateDawnDevice(wgpu::BackendType::Metal, &desc);
  if (!device) { return nullptr; }
  return new Device(device);
}

bool System_IsRunning() { return gNumWindows > 0; }

bool System_HasPendingEvents() {
  return !gEventQueue.empty();
}

Event* System_GetNextEvent() {
  if (!gInitialized) {
    Initialize();
    gInitialized = true;
  }
  // FIXME: block until there's an event in gEventQueue
  Event* event = gEventQueue.back();
  gEventQueue.pop_back();
  return event;
#if 0
  int    height = [[nsEvent.window contentView] frame].size.height;
  event->position[0] = nsEvent.locationInWindow.x;
  event->position[1] = height - nsEvent.locationInWindow.y;
  event->modifiers = ToToucanEventModifiers(nsEvent.modifierFlags);
  event->button = 0;
  event->type = EventType::Unknown;

  switch (nsEvent.type) {
    case UIEventTypeLeftMouseDown:
      event->type = EventType::MouseDown;
      event->button = 0;
      break;
    case UIEventTypeRightMouseDown:
      event->type = EventType::MouseDown;
      event->button = 2;
      break;
    case UIEventTypeMouseEntered: break;
    case UIEventTypeMouseExited: break;
    case UIEventTypeLeftMouseUp:
      event->type = EventType::MouseUp;
      event->button = 0;
      break;
    case UIEventTypeRightMouseUp:
      event->type = EventType::MouseUp;
      event->button = 2;
      break;
    case UIEventTypeOtherMouseDown:
      event->type = EventType::MouseDown;
      event->button = 1;
      break;
    case UIEventTypeOtherMouseUp:
      event->type = EventType::MouseUp;
      event->button = 1;
      break;
    case UIEventTypeKeyDown: break;
    case UIEventTypeKeyUp: break;
    case UIEventTypeMouseMoved:
    case UIEventTypeLeftMouseDragged:
    case UIEventTypeRightMouseDragged:
      if (nsEvent.window) { event->type = EventType::MouseMove; }
      break;
    case UIEventTypeAppKitDefined:
      switch ([nsEvent subtype]) {
        case UIEventSubtypeWindowExposed: break;
        case UIEventSubtypeApplicationActivated: break;
        case UIEventSubtypeScreenChanged: break;
        case UIEventSubtypeWindowMoved: break;
        default: break;
      }
      break;
    case UIEventTypeApplicationDefined: break;
    case UIEventTypeCursorUpdate: break;
    case UIEventTypeSystemDefined: break;
    case UIEventTypeFlagsChanged: break;
    case UIEventTypePeriodic: break;
    case UIEventTypeQuickLook: break;
    default: event->type = EventType::Unknown;
  }
  return event;
  #endif
}

const uint32_t* System_GetScreenSize() {
  static uint32_t screenSize[2];
  screenSize[0] = [[UIScreen mainScreen] bounds].size.width;
  screenSize[1] = [[UIScreen mainScreen] bounds].size.height;
  return screenSize;
}

double System_GetCurrentTime() {
  struct timeval now;

  gettimeofday(&now, NULL);
  return static_cast<double>(now.tv_sec) + static_cast<double>(now.tv_usec) / 1000000.0;
}

void System_Print(Array* buffer) {
  NSString* str = [[NSString alloc] initWithBytes:buffer->ptr
                                           length:buffer->length
                                         encoding:NSUTF8StringEncoding];

  os_log_t customLog = os_log_create("org.toucanlang.sample.window", "silly");

  os_log(customLog, "%{public}@", str);
}

void System_PrintLine(Array* buffer) {
  NSString* str = [[NSString alloc] initWithBytes:buffer->ptr
                                           length:buffer->length
                                         encoding:NSUTF8StringEncoding];

  os_log_t customLog = os_log_create("org.toucanlang.sample.window", "silly");

  os_log(customLog, "%{public}@\n", str);
}

};  // namespace Toucan

@implementation ToucanSceneDelegate

- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {

    // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
    // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
    // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
}
@end

@implementation ToucanViewController

- (void)viewDidLoad {
  [super viewDidLoad];
  auto metalDevice = MTLCreateSystemDefaultDevice();
  if (![self view] || !metalDevice) {
    assert(!"Metal is not supported on this device");
    self.view = [[UIView alloc] initWithFrame:self.view.frame];
    return;
  }
  MTKView* mtkView = (MTKView*)[self view];
  [mtkView setDevice:metalDevice];
  [mtkView setBackgroundColor:[UIColor blackColor]];
}

- (void)touchesBegan:(NSSet<UITouch*>*)touches withEvent:(UIEvent*)e {
  auto event = new Toucan::Event();
  event->type = Toucan::EventType::TouchStart;
  event->numTouches = -1;
  int i = 0;
  for (UITouch* touch in touches) {
    auto position = [touch locationInView:self.view];
    event->touches[i][0] = position.x;
    event->touches[i][1] = position.y;
    i++;
  }
  gEventQueue.push_back(event);
}

@end
