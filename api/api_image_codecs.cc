// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <assert.h>
#include <stdio.h>

#include <memory>

#include <jpeglib.h>

#include <ast/type.h>

namespace Toucan {

struct ImageDecoder {
  Type*                         pixelFormat;
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr         jerr;
  uint32_t                      size[2];
};

namespace {
void AssertSupportedPixelFormat(Type* pixelFormat) {
  assert(pixelFormat->IsClass());
  auto classType = static_cast<ClassType*>(pixelFormat);
  auto parent = classType->GetParent();
  assert(parent->GetName() == "PixelFormat");
  auto templateArgs = parent->GetTemplateArgs();
  assert(templateArgs.size() == 2);
}
}  // namespace

ImageDecoder* ImageDecoder_ImageDecoder(int qualifiers, Type* pixelFormat, Object* encodedImage) {
  uint32_t length = encodedImage->controlBlock->arrayLength;
  auto     result = new ImageDecoder();
  result->pixelFormat = pixelFormat;
  AssertSupportedPixelFormat(pixelFormat);
  result->cinfo.err = jpeg_std_error(&result->jerr);
  jpeg_create_decompress(&result->cinfo);
  jpeg_mem_src(&result->cinfo, static_cast<unsigned char*>(encodedImage->ptr), length);
  jpeg_read_header(&result->cinfo, TRUE);
  result->size[0] = result->cinfo.image_width;
  result->size[1] = result->cinfo.image_height;
  return result;
}

const uint32_t* ImageDecoder_GetSize(ImageDecoder* This) { return This->size; }

void ImageDecoder_Decode(ImageDecoder* This, Object* dest, uint32_t bufferWidth) {
  jpeg_start_decompress(&This->cinfo);
  uint32_t* p = static_cast<uint32_t*>(dest->ptr);

  int        row_stride = This->cinfo.output_width * This->cinfo.output_components;
  JSAMPARRAY scanline = (*This->cinfo.mem->alloc_sarray)(
      reinterpret_cast<j_common_ptr>(&This->cinfo), JPOOL_IMAGE, row_stride, 1);
  uint32_t rshift = 0;
  uint32_t gshift = 8;
  uint32_t bshift = 16;
  if (static_cast<ClassType*>(This->pixelFormat)->GetName() == "BGRA8unorm") {
    rshift = 16;
    bshift = 0;
  }
  while (This->cinfo.output_scanline < This->cinfo.output_height) {
    jpeg_read_scanlines(&This->cinfo, scanline, 1);
    if (This->cinfo.output_components == 3) {
      uint8_t* buf = scanline[0];
      for (int x = 0; x < This->size[0]; x++) {
        uint8_t r = *buf++;
        uint8_t g = *buf++;
        uint8_t b = *buf++;
        p[x] = 0xFF000000 | r << rshift | g << gshift | b << bshift;
      }
    } else {
      assert(!"unsupported jpeg component count");
    }
    p += bufferWidth;
  }
  jpeg_finish_decompress(&This->cinfo);
}

void ImageDecoder_Destroy(ImageDecoder* This) {
  jpeg_destroy_decompress(&This->cinfo);
  delete This;
}

};  // namespace Toucan
