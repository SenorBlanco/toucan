// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <assert.h>
#include <stdio.h>

#include <cstring>
#include <unordered_map>

#if TARGET_OS_IS_WASM
#include <emscripten.h>
#endif

#include <webgpu/webgpu_cpp.h>

#include <ast/native_class.h>
#include <ast/type.h>
#include "api_internal.h"

namespace Toucan {

namespace {

uint32_t BytesPerPixel(wgpu::TextureFormat format) {
  switch (format) {
    case wgpu::TextureFormat::RGBA8Unorm:
    case wgpu::TextureFormat::RGBA8Snorm:
    case wgpu::TextureFormat::RGBA8Uint:
    case wgpu::TextureFormat::RGBA8Sint:
    case wgpu::TextureFormat::BGRA8Unorm: return 4;
    default: assert(!"unknown Format"); return 0;
  }
}

wgpu::TextureUsage ToDawnTextureUsage(int qualifiers) {
  wgpu::TextureUsage result = wgpu::TextureUsage::CopySrc | wgpu::TextureUsage::CopyDst;

  if (qualifiers & Type::Qualifier::Storage) { result |= wgpu::TextureUsage::StorageBinding; }
  if (qualifiers & Type::Qualifier::Sampleable) { result |= wgpu::TextureUsage::TextureBinding; }
  if (qualifiers & Type::Qualifier::Renderable) { result |= wgpu::TextureUsage::RenderAttachment; }
  return result;
}

wgpu::LoadOp ToDawnLoadOp(LoadOp loadOp) {
  switch (loadOp) {
    case LoadUndefined: return wgpu::LoadOp::Undefined;
    case Load: return wgpu::LoadOp::Load;
    case Clear: return wgpu::LoadOp::Clear;
    default: assert(!"unknown LoadOp"); return wgpu::LoadOp::Load;
  }
}

wgpu::StoreOp ToDawnStoreOp(StoreOp loadOp) {
  switch (loadOp) {
    case StoreUndefined: return wgpu::StoreOp::Undefined;
    case Store: return wgpu::StoreOp::Store;
    case Discard: return wgpu::StoreOp::Discard;
    default: assert(!"unknown StoreOp"); return wgpu::StoreOp::Store;
  }
}

}  // namespace

struct TextureView {
  TextureView(wgpu::TextureView v) : view(v) {}
  wgpu::TextureView view;
};

struct SampleableTexture1D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2DArray : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture3D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTextureCube : public TextureView {
  using TextureView::TextureView;
};

struct Texture {
  Texture(wgpu::Texture t, wgpu::TextureView v, const wgpu::Extent3D& s, wgpu::TextureFormat f)
      : texture(t), view(v), size(s), format(f) {}
  Texture(int                    qualifiers,
          Type*                  pixelFormat,
          wgpu::Device           device,
          wgpu::TextureDimension d,
          wgpu::Extent3D         s)
      : size(s), format(ToDawnTextureFormat(pixelFormat)) {
    wgpu::TextureDescriptor desc;
    desc.usage = ToDawnTextureUsage(qualifiers);
    desc.size = s;
    desc.format = format;
    desc.dimension = d;
    texture = device.CreateTexture(&desc);
    view = texture.CreateView();
  }
  Texture(Texture* t, wgpu::TextureViewDimension dimension, uint32_t arrayLayer, uint32_t mipLevel)
      : Texture(t->texture, t->CreateView(dimension, arrayLayer, mipLevel), t->size, t->format) {}
  uint32_t MinBufferWidth() {
    uint32_t bytesPerPixel = BytesPerPixel(format);
    return (((size.width * bytesPerPixel + 255) >> 8) << 8) / bytesPerPixel;
  }

  void CopyFromBuffer(wgpu::CommandEncoder encoder,
                      wgpu::Buffer         source,
                      wgpu::Extent3D       extent,
                      wgpu::Origin3D       origin) {
    wgpu::ImageCopyBuffer sourceICB;
    sourceICB.buffer = source;
    sourceICB.layout.bytesPerRow = MinBufferWidth() * BytesPerPixel(format);
    sourceICB.layout.rowsPerImage = size.height;
    wgpu::ImageCopyTexture destICT;
    destICT.texture = texture;
    destICT.origin = origin;
    encoder.CopyBufferToTexture(&sourceICB, &destICT, &extent);
  }
  wgpu::TextureView CreateView(wgpu::TextureViewDimension dimension,
                               uint32_t                   arrayLayer,
                               uint32_t                   mipLevel) const {
    wgpu::TextureViewDescriptor desc;
    desc.format = format;
    desc.dimension = dimension;
    desc.baseMipLevel = mipLevel;
    desc.mipLevelCount = 1;
    desc.baseArrayLayer = arrayLayer;
    desc.arrayLayerCount = 1;
    return texture.CreateView(&desc);
  }
  wgpu::Texture       texture;
  wgpu::TextureView   view;
  wgpu::Extent3D      size;
  wgpu::TextureFormat format;
};

struct Texture1D : public Texture {
  using Texture::Texture;
};
struct Texture2D : public Texture {
  using Texture::Texture;
};
struct Texture2DArray : public Texture {
  using Texture::Texture;
};
struct Texture3D : public Texture {
  using Texture::Texture;
};
struct TextureCube : public Texture {
  using Texture::Texture;
};

struct Sampler {
  Sampler(wgpu::Sampler s) : sampler(s) {}
  wgpu::Sampler sampler;
};

struct Buffer {
  Buffer(wgpu::Device d, wgpu::Buffer b, int l, int s, Type* t)
      : device(d), buffer(b), length(l), sizeInBytes(s), type(t) {}
  wgpu::Device device;
  wgpu::Buffer buffer;
  int          length;
  int          sizeInBytes;
  Type*        type;
  Object       mappedObject = {nullptr, nullptr};
};

struct RenderPipeline {
  RenderPipeline(wgpu::RenderPipeline p) : pipeline(p) {}
  wgpu::RenderPipeline pipeline;
};

struct ComputePipeline {
  ComputePipeline(wgpu::ComputePipeline p) : pipeline(p) {}
  wgpu::ComputePipeline pipeline;
};

wgpu::TextureFormat ToDawnTextureFormat(Type* format) {
  assert(format->IsClass());
  auto classType = static_cast<ClassType*>(format);
  if (classType->GetName() == "RGBA8unorm") {
    return wgpu::TextureFormat::RGBA8Unorm;
  } else if (classType->GetName() == "BGRA8unorm") {
    return wgpu::TextureFormat::BGRA8Unorm;
  } else if (classType->GetName() == "RGBA8snorm") {
    return wgpu::TextureFormat::RGBA8Snorm;
  } else if (classType->GetName() == "Depth24Plus") {
    return wgpu::TextureFormat::Depth24Plus;
  } else if (classType->GetName() == "PreferredSwapChainFormat") {
    return GetPreferredSwapChainFormat();
  } else {
    assert(!"unknown Format");
    return wgpu::TextureFormat::RGBA8Unorm;
  }
}

wgpu::TextureSampleType ToDawnTextureSampleType(ClassType* type) {
  Type* arg = type->GetTemplateArgs()[0];
  if (arg->IsFloat()) {
    return wgpu::TextureSampleType::Float;
  } else if (arg->IsInt()) {
    return wgpu::TextureSampleType::Sint;
  } else if (arg->IsUInt()) {
    return wgpu::TextureSampleType::Uint;
  } else {
    assert(!"unknown texture sample type");
    return wgpu::TextureSampleType::Float;
  }
}

static wgpu::VertexFormat toDawnVertexFormat(Type* type) {
  if (type->IsVector()) {
    VectorType* v = static_cast<VectorType*>(type);
    if (v->GetComponentType()->IsInt()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Sint32x2;
        case 3: return wgpu::VertexFormat::Sint32x3;
        case 4: return wgpu::VertexFormat::Sint32x4;
      }
    } else if (v->GetComponentType()->IsFloat()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Float32x2;
        case 3: return wgpu::VertexFormat::Float32x3;
        case 4: return wgpu::VertexFormat::Float32x4;
      }
    } else if (v->GetComponentType()->IsUInt()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Uint32x2;
        case 3: return wgpu::VertexFormat::Uint32x3;
        case 4: return wgpu::VertexFormat::Uint32x4;
      }
    }
  } else if (type->IsInt()) {
    return wgpu::VertexFormat::Sint32;
  } else if (type->IsFloat()) {
    return wgpu::VertexFormat::Float32;
  } else if (type->IsUInt()) {
    return wgpu::VertexFormat::Uint32;
  }
  assert(!"invalid vertex format");
  return wgpu::VertexFormat::Uint8x2;
}

static wgpu::IndexFormat toDawnIndexFormat(Type* type) {
  if (type->IsUInt()) {
    return wgpu::IndexFormat::Uint32;
  } else if (type->IsUShort()) {
    return wgpu::IndexFormat::Uint16;
  }
  assert(!"invalid index format");
  return wgpu::IndexFormat::Undefined;
}

static wgpu::AddressMode ToDawnAddressMode(AddressMode mode) {
  switch (mode) {
    case AddressMode::Repeat: return wgpu::AddressMode::Repeat;
    case AddressMode::MirrorRepeat: return wgpu::AddressMode::MirrorRepeat;
    case AddressMode::ClampToEdge: return wgpu::AddressMode::ClampToEdge;
  }
  assert(!"unknown address mode");
  return wgpu::AddressMode::Repeat;
}

static wgpu::FilterMode ToDawnFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::FilterMode::Nearest;
    case FilterMode::Linear: return wgpu::FilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::FilterMode::Nearest;
}

static wgpu::MipmapFilterMode ToDawnMipmapFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::MipmapFilterMode::Nearest;
    case FilterMode::Linear: return wgpu::MipmapFilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::MipmapFilterMode::Nearest;
}

// FIXME: this should handle a mask, properly
static wgpu::BufferUsage toDawnBufferUsage(int qualifiers) {
  if (qualifiers == 0) { qualifiers = Type::Qualifier::WriteOnly; }
  wgpu::BufferUsage result = wgpu::BufferUsage::None;
  bool              gpu = false;
  if (qualifiers & Type::Qualifier::Index) {
    result |= wgpu::BufferUsage::Index;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Vertex) {
    result |= wgpu::BufferUsage::Vertex;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Uniform) {
    result |= wgpu::BufferUsage::Uniform;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Storage) {
    result |= wgpu::BufferUsage::Storage;
    gpu = true;
  }
  if (gpu) {
    result |= wgpu::BufferUsage::CopyDst;
    // F*XME: handle readonly, writeonly, readwrite storage
  } else {
    if (qualifiers & (Type::Qualifier::ReadOnly | Type::Qualifier::ReadWrite)) {
      result |= wgpu::BufferUsage::MapRead | wgpu::BufferUsage::CopyDst;
    }
    if (qualifiers & (Type::Qualifier::WriteOnly | Type::Qualifier::ReadWrite)) {
      result |= wgpu::BufferUsage::MapWrite | wgpu::BufferUsage::CopySrc;
    }
  }
  return result;
}

static wgpu::PrimitiveTopology toDawnPrimitiveTopology(PrimitiveTopology type) {
  switch (type) {
    case PointList: return wgpu::PrimitiveTopology::PointList;
    case LineList: return wgpu::PrimitiveTopology::LineList;
    case LineStrip: return wgpu::PrimitiveTopology::LineStrip;
    case TriangleList: return wgpu::PrimitiveTopology::TriangleList;
    case TriangleStrip: return wgpu::PrimitiveTopology::TriangleStrip;
    default: assert(!"unknown PrimitiveTopology"); return wgpu::PrimitiveTopology::PointList;
  }
}

wgpu::VertexBufferLayout toDawnVertexBufferLayout(Type*                               vertexInput,
                                                  std::vector<wgpu::VertexAttribute>* vaDescs) {
  size_t start = vaDescs->size();
  if (vertexInput->IsClass()) {
    auto               classType = static_cast<ClassType*>(vertexInput);
    const FieldVector& fields = classType->GetFields();
    for (int i = 0; i < fields.size(); i++) {
      wgpu::VertexAttribute vaDesc;
      vaDesc.shaderLocation = vaDescs->size();
      vaDesc.offset = fields[i]->offset;
      vaDesc.format = toDawnVertexFormat(fields[i]->type);
      vaDescs->push_back(vaDesc);
    }
  } else {
    wgpu::VertexAttribute vaDesc;
    vaDesc.shaderLocation = vaDescs->size();
    vaDesc.offset = 0;
    vaDesc.format = toDawnVertexFormat(vertexInput);
    vaDescs->push_back(vaDesc);
  }
  wgpu::VertexBufferLayout input;
  input.arrayStride = vertexInput->GetSizeInBytes();
  input.attributeCount = vaDescs->size() - start;
  // Cast the start offset to pointer; this will be added to the vaDesc pointer
  // in FinalizeVertexLayouts. This is necessary to accommodate reallocation
  // of the vertex attribute vector.
  input.attributes = reinterpret_cast<wgpu::VertexAttribute*>(start);
  return input;
}

wgpu::BufferBindingType toDawnBufferBindingType(int qualifiers) {
  if (qualifiers & Type::Qualifier::Uniform) { return wgpu::BufferBindingType::Uniform; }
  if (qualifiers & Type::Qualifier::Storage) {
    if (qualifiers & Type::Qualifier::ReadOnly) {
      return wgpu::BufferBindingType::ReadOnlyStorage;
    } else {
      return wgpu::BufferBindingType::Storage;
    }
  }
  assert(!"invalid qualifiers for buffer binding");
  return wgpu::BufferBindingType::Undefined;
}

// FIXME: store this in Device.
std::unordered_map<Type*, wgpu::BindGroupLayout> bindGroupLayoutCache;

static wgpu::BindGroupLayoutEntry CreateBindGroupLayoutEntry(uint32_t binding,
                                                             Type*    type,
                                                             int      qualifiers) {
  assert(!type->IsPtr());
  if (!type->IsClass()) {
    assert(!"invalid field type in bind group (not class)");
    return {};
  }
  ClassType*                 classType = static_cast<ClassType*>(type);
  wgpu::BindGroupLayoutEntry entry;
  // FIXME: get visibilty from qualifiers
  entry.binding = binding;
  if (qualifiers & Type::Qualifier::Storage) {
    entry.visibility = wgpu::ShaderStage::Compute | wgpu::ShaderStage::Fragment;
  } else {
    entry.visibility =
        wgpu::ShaderStage::Vertex | wgpu::ShaderStage::Fragment | wgpu::ShaderStage::Compute;
  }
  ClassType* templ = classType->GetTemplate();
  if (templ == NativeClass::Buffer) {
    entry.buffer.type = toDawnBufferBindingType(qualifiers);
  } else if (templ == NativeClass::SampleableTexture1D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e1D;
  } else if (templ == NativeClass::SampleableTexture2D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2D;
  } else if (templ == NativeClass::SampleableTexture3D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e3D;
  } else if (templ == NativeClass::SampleableTexture2DArray) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2DArray;
  } else if (templ == NativeClass::SampleableTextureCube) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::Cube;
  } else if (classType == NativeClass::Sampler) {
    entry.sampler.type = wgpu::SamplerBindingType::Filtering;
  } else {
    assert(!"invalid field type in bind group");
  }
  return entry;
}

static void CreateBindGroupLayoutEntries(ClassType*                               classType,
                                         int                                      qualifiers,
                                         std::vector<wgpu::BindGroupLayoutEntry>* entries) {
  if (classType->GetParent()) {
    CreateBindGroupLayoutEntries(classType->GetParent(), qualifiers, entries);
  }
  if (classType->IsNative()) {
    auto entry = CreateBindGroupLayoutEntry(0, classType, qualifiers);
    entries->push_back(entry);
  } else {
    uint32_t bindingIndex = 0;
    for (const auto& field : classType->GetFields()) {
      assert(field->type->IsPtr());
      Type* type = static_cast<PtrType*>(field->type)->GetBaseType();
      type = type->GetUnqualifiedType(&qualifiers);
      auto entry = CreateBindGroupLayoutEntry(bindingIndex, type, qualifiers);
      bindingIndex++;
      entries->push_back(entry);
    }
  }
}

static wgpu::BindGroupLayout GetOrCreateBindGroupLayout(Device* device, Type* type) {
  assert(!type->IsPtr());
  if (auto layout = bindGroupLayoutCache[type]) { return layout; }
  int qualifiers;
  type = type->GetUnqualifiedType(&qualifiers);
  std::vector<wgpu::BindGroupLayoutEntry> entries;
  assert(type->IsClass());
  CreateBindGroupLayoutEntries(static_cast<ClassType*>(type), qualifiers, &entries);
  wgpu::BindGroupLayoutDescriptor desc;
  desc.entryCount = entries.size();
  desc.entries = entries.data();
  auto layout = device->device.CreateBindGroupLayout(&desc);
  bindGroupLayoutCache[type] = layout;
  return layout;
}

wgpu::BindGroupEntry CreateBindGroupEntry(Type* type, int binding, Object* object) {
  wgpu::BindGroupEntry entry;
  entry.binding = binding;
  entry.buffer = nullptr;
  entry.sampler = nullptr;
  entry.textureView = nullptr;
  if (type->IsPtr()) { type = static_cast<PtrType*>(type)->GetBaseType(); }
  int qualifiers = 0;
  type = type->GetUnqualifiedType(&qualifiers);
  assert(type->IsClass() && "bind group entry must be of class type");
  ClassType* c = static_cast<ClassType*>(type);
  ClassType* templ = c->GetTemplate();
  if (templ == NativeClass::SampleableTexture1D || templ == NativeClass::SampleableTexture2D ||
      templ == NativeClass::SampleableTexture3D || templ == NativeClass::SampleableTexture2DArray ||
      templ == NativeClass::SampleableTextureCube) {
    TextureView* textureView = static_cast<TextureView*>(object->ptr);
    entry.textureView = textureView->view;
  } else if (c == NativeClass::Sampler) {
    Sampler* sampler = static_cast<Sampler*>(object->ptr);
    entry.sampler = sampler->sampler;
  } else if (templ == NativeClass::Buffer) {
    Buffer* buffer = static_cast<Buffer*>(object->ptr);
    entry.buffer = buffer->buffer;
    entry.size = buffer->sizeInBytes;
  }
  return entry;
}

struct BindGroup {
  BindGroup(wgpu::BindGroup b) : bindGroup(b) {}
  wgpu::BindGroup bindGroup;
};

struct BindGroupLayout {
  BindGroupLayout(wgpu::BindGroupLayout b) : bindGroupLayout(b) {}
  wgpu::BindGroupLayout bindGroupLayout;
};

struct ColorAttachment {
  ColorAttachment(const wgpu::RenderPassColorAttachment& a) : attachment(a) {}
  wgpu::RenderPassColorAttachment attachment;
};

struct DepthStencilAttachment {
  DepthStencilAttachment(const wgpu::RenderPassDepthStencilAttachment& a) : attachment(a) {}
  wgpu::RenderPassDepthStencilAttachment attachment;
};

struct RenderPass {
  RenderPass(wgpu::RenderPassEncoder e) : encoder(e) {}
  wgpu::RenderPassEncoder encoder;
};

struct ComputePass {
  ComputePass(wgpu::ComputePassEncoder e) : encoder(e) {}
  wgpu::ComputePassEncoder encoder;
};

struct CommandEncoder {
  CommandEncoder(wgpu::CommandEncoder e) : encoder(e) {}
  wgpu::CommandEncoder encoder;
};

struct CommandBuffer {
  CommandBuffer(wgpu::CommandBuffer cb) : commandBuffer(cb) {}
  wgpu::CommandBuffer commandBuffer;
};

struct Queue {
  Queue(wgpu::Queue q) : queue(q) {}
  wgpu::Queue queue;
};

Queue* Device_GetQueue(Device* device) { return new Queue(device->device.GetQueue()); }

void Device_Destroy(Device* This) { delete This; }

void Queue_Destroy(Queue* This) { delete This; }

wgpu::ShaderModule createShaderModule(Device* device, Method* m) {
  wgpu::ShaderModuleDescriptor desc;
#if TARGET_OS_IS_WASM
  wgpu::ShaderModuleWGSLDescriptor wgslDesc;
  wgslDesc.code = m->wgsl.data();
  desc.nextInChain = &wgslDesc;
#else
  wgpu::ShaderModuleSPIRVDescriptor spirvDesc;
  spirvDesc.codeSize = m->spirv.size();
  spirvDesc.code = m->spirv.data();
  desc.nextInChain = &spirvDesc;
#endif
  return device->device.CreateShaderModule(&desc);
}

struct PipelineLayout {
  std::vector<wgpu::BindGroupLayout>    bindGroupLayouts;
  std::vector<wgpu::ColorTargetState>   colorTargets;
  wgpu::DepthStencilState               depthStencilTarget;
  std::vector<wgpu::VertexAttribute>    vertexAttributes;
  std::vector<wgpu::VertexBufferLayout> vertexBufferLayouts;
  wgpu::IndexFormat                     indexFormat = wgpu::IndexFormat::Undefined;

  void FinalizeVertexLayouts() {
    // Convert each vertexLayout's "attributes" pointers back to an offset,
    // and add it to the vertexAttributes base.
    auto base = vertexAttributes.data();
    for (auto& vertexLayout : vertexBufferLayouts) {
      vertexLayout.attributes = base + reinterpret_cast<size_t>(vertexLayout.attributes);
    }
  }
};

static void ExtractPipelineLayout(ClassType* classType, Device* device, PipelineLayout* out) {
  if (classType->GetParent()) { ExtractPipelineLayout(classType->GetParent(), device, out); }
  for (const auto& field : classType->GetFields()) {
    Type* type = field->type;

    assert(type->IsPtr());
    type = static_cast<PtrType*>(type)->GetBaseType();
    int   qualifiers;
    Type* unqualifiedType = type->GetUnqualifiedType(&qualifiers);
    assert(unqualifiedType->IsClass());

    ClassType* classType = static_cast<ClassType*>(unqualifiedType);
    if (classType->GetTemplate() == NativeClass::ColorAttachment) {
      wgpu::ColorTargetState colorTargetState;
      const auto&            templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      colorTargetState.format = ToDawnTextureFormat(templateArgs[0]);
      out->colorTargets.push_back(colorTargetState);
    } else if (classType->GetTemplate() == NativeClass::DepthStencilAttachment) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      out->depthStencilTarget.format = ToDawnTextureFormat(templateArgs[0]);
    } else if (classType->GetTemplate() == NativeClass::Buffer) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      assert(templateArgs[0]->IsUnsizedArray());
      Type* elementType = static_cast<ArrayType*>(templateArgs[0])->GetElementType();
      if (qualifiers == Type::Qualifier::Vertex) {
        auto layout = toDawnVertexBufferLayout(elementType, &out->vertexAttributes);
        out->vertexBufferLayouts.push_back(layout);
      } else if (qualifiers == Type::Qualifier::Index) {
        out->indexFormat = toDawnIndexFormat(elementType);
      }
    } else if (classType->GetTemplate() == NativeClass::BindGroup) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      wgpu::BindGroupLayout layout = GetOrCreateBindGroupLayout(device, templateArgs[0]);
      out->bindGroupLayouts.push_back(layout);
    } else {
      assert("!invalid type for pipeline variable");
    }
  }
}

struct PipelineData {
  std::vector<wgpu::BindGroup>                 bindGroups;
  std::vector<wgpu::RenderPassColorAttachment> colorAttachments;
  wgpu::RenderPassDepthStencilAttachment       depthStencilAttachment;
  std::vector<wgpu::Buffer>                    vertexBuffers;
  wgpu::Buffer                                 indexBuffer;
  wgpu::IndexFormat                            indexFormat;

  void Set(wgpu::RenderPassEncoder encoder) {
    for (int i = 0; i < bindGroups.size(); i++) {
      if (bindGroups[i]) { encoder.SetBindGroup(i, bindGroups[i]); }
    }
    for (int i = 0; i < vertexBuffers.size(); i++) {
      if (vertexBuffers[i]) { encoder.SetVertexBuffer(i, vertexBuffers[i]); }
    }
    if (indexBuffer) { encoder.SetIndexBuffer(indexBuffer, indexFormat); }
  }

  void Set(wgpu::ComputePassEncoder encoder) {
    for (int i = 0; i < bindGroups.size(); i++) {
      if (bindGroups[i]) { encoder.SetBindGroup(i, bindGroups[i]); }
    }
  }
};

static void ExtractPipelineData(ClassType* classType, void* data, PipelineData* out) {
  if (classType->GetParent()) { ExtractPipelineData(classType->GetParent(), data, out); }
  for (const auto& field : classType->GetFields()) {
    Type* fieldType = field->type;
    assert(fieldType->IsPtr());
    fieldType = static_cast<PtrType*>(fieldType)->GetBaseType();
    int qualifiers;
    fieldType = fieldType->GetUnqualifiedType(&qualifiers);
    Object object = *reinterpret_cast<Object*>((uint8_t*)data + field->offset);
    assert(fieldType->IsClass());
    auto classType = static_cast<ClassType*>(fieldType);
    if (classType->GetTemplate() == NativeClass::ColorAttachment && object.ptr) {
      out->colorAttachments.push_back(static_cast<ColorAttachment*>(object.ptr)->attachment);
    } else if (classType->GetTemplate() == NativeClass::DepthStencilAttachment && object.ptr) {
      out->depthStencilAttachment = static_cast<DepthStencilAttachment*>(object.ptr)->attachment;
    } else if (classType->GetTemplate() == NativeClass::Buffer &&
               qualifiers == Type::Qualifier::Vertex) {
      out->vertexBuffers.push_back(object.ptr ? static_cast<Buffer*>(object.ptr)->buffer : nullptr);
    } else if (classType->GetTemplate() == NativeClass::Buffer &&
               qualifiers == Type::Qualifier::Index) {
      if (auto buffer = static_cast<Buffer*>(object.ptr)) {
        out->indexBuffer = buffer ? buffer->buffer : nullptr;
        out->indexFormat =
            toDawnIndexFormat(static_cast<ArrayType*>(buffer->type)->GetElementType());
      }
    } else if (classType->GetTemplate() == NativeClass::BindGroup) {
      out->bindGroups.push_back(object.ptr ? static_cast<BindGroup*>(object.ptr)->bindGroup
                                           : nullptr);
    }
  }
}

RenderPipeline* RenderPipeline_RenderPipeline(int               qualifiers,
                                              Type*             type,
                                              Device*           device,
                                              Object*           depthStencil,
                                              PrimitiveTopology primitiveTopology) {
  if (!type->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(type);
  wgpu::ShaderModule vertexShader, fragmentShader;
  for (auto& method : classType->GetMethods()) {
    if (method->shaderType == ShaderType::Vertex) {
      if (vertexShader) {
        assert(!"more than one vertex shader specified");
        return nullptr;
      }
      vertexShader = createShaderModule(device, method.get());
    } else if (method->shaderType == ShaderType::Fragment) {
      if (fragmentShader) {
        assert(!"more than one fragment shader specified");
        return nullptr;
      }
      fragmentShader = createShaderModule(device, method.get());
    }
  }
  PipelineLayout pipelineLayout;
  ExtractPipelineLayout(classType, device, &pipelineLayout);
  pipelineLayout.FinalizeVertexLayouts();

  wgpu::VertexState vertexState;
  vertexState.module = vertexShader;
  vertexState.entryPoint = "main";
  vertexState.bufferCount = pipelineLayout.vertexBufferLayouts.size();
  vertexState.buffers = pipelineLayout.vertexBufferLayouts.data();
  wgpu::RenderPipelineDescriptor rpDesc;
  wgpu::DepthStencilState        depthStencilState;
  if (depthStencil->ptr) {
    Type* type = depthStencil->controlBlock->type;
    assert(type->IsClass());
    ClassType*  classType = static_cast<ClassType*>(type);
    const auto& templateArgs = classType->GetTemplateArgs();
    assert(templateArgs.size() == 1);
    depthStencilState.format = ToDawnTextureFormat(templateArgs[0]);
    depthStencilState.depthWriteEnabled = true;
    depthStencilState.depthCompare = wgpu::CompareFunction::Less;
  }
  wgpu::FragmentState fragmentState;
  fragmentState.module = fragmentShader;
  fragmentState.entryPoint = "main";
  fragmentState.constants = nullptr;
  fragmentState.targetCount = pipelineLayout.colorTargets.size();
  fragmentState.targets = pipelineLayout.colorTargets.data();
  wgpu::PrimitiveState           primitiveState;
  wgpu::PipelineLayoutDescriptor desc;
  desc.bindGroupLayoutCount = pipelineLayout.bindGroupLayouts.size();
  desc.bindGroupLayouts = pipelineLayout.bindGroupLayouts.data();
  rpDesc.layout = device->device.CreatePipelineLayout(&desc);
  rpDesc.vertex = vertexState;
  rpDesc.fragment = &fragmentState;
  rpDesc.primitive.topology = toDawnPrimitiveTopology(primitiveTopology);
  if (primitiveTopology == LineStrip || primitiveTopology == TriangleStrip) {
    rpDesc.primitive.stripIndexFormat = pipelineLayout.indexFormat;
  }
  if (depthStencil->ptr) { rpDesc.depthStencil = &depthStencilState; }
  return new RenderPipeline(device->device.CreateRenderPipeline(&rpDesc));
}

void RenderPipeline_Destroy(RenderPipeline* This) { delete This; }

ComputePipeline* ComputePipeline_ComputePipeline(int     qualifiers,
                                                 Type*   computeLayout,
                                                 Device* device) {
  if (!computeLayout->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(computeLayout);
  wgpu::ShaderModule computeShader;
  for (auto& method : classType->GetMethods()) {
    if (method->shaderType == ShaderType::Compute) {
      if (computeShader) {
        assert(!"more than one compute shader specified");
        return nullptr;
      }
      computeShader = createShaderModule(device, method.get());
    }
  }
  wgpu::ProgrammableStageDescriptor computeState;
  computeState.module = computeShader;
  computeState.entryPoint = "main";
  wgpu::ComputePipelineDescriptor cpDesc;
  PipelineLayout                  pipelineLayout;
  ExtractPipelineLayout(classType, device, &pipelineLayout);
  wgpu::PipelineLayoutDescriptor desc;
  desc.bindGroupLayoutCount = pipelineLayout.bindGroupLayouts.size();
  desc.bindGroupLayouts = pipelineLayout.bindGroupLayouts.data();
  cpDesc.layout = device->device.CreatePipelineLayout(&desc);
  cpDesc.compute = computeState;
  return new ComputePipeline(device->device.CreateComputePipeline(&cpDesc));
}

void ComputePipeline_Destroy(ComputePipeline* This) { delete This; }

BindGroup* BindGroup_BindGroup(int qualifiers, Type* type, Device* device, Object* data) {
  assert(type->IsClass() && "bind group argument must be a class type");
  ClassType*                        classType = static_cast<ClassType*>(type);
  wgpu::BindGroupDescriptor         desc;
  std::vector<wgpu::BindGroupEntry> entries;
  if (classType->IsNative()) {
    auto entry = CreateBindGroupEntry(data->controlBlock->type, 0, data);
    desc.entryCount = 1;
    desc.entries = &entry;
    desc.layout = GetOrCreateBindGroupLayout(device, data->controlBlock->type);
  } else {
    desc.entryCount = classType->GetFields().size();
    for (int i = 0; i < desc.entryCount; i++) {
      Field* field = classType->GetFields()[i].get();
      Object object = *reinterpret_cast<Object*>((uint8_t*)data->ptr + field->offset);
      entries.push_back(CreateBindGroupEntry(field->type, i, &object));
    }
    desc.entries = entries.data();
    desc.layout = GetOrCreateBindGroupLayout(device, classType);
  }
  return new BindGroup(device->device.CreateBindGroup(&desc));
}

void BindGroup_Destroy(BindGroup* This) { delete This; }

void SampleableTexture1D_Destroy(SampleableTexture1D* This) { delete This; }

void SampleableTexture2D_Destroy(SampleableTexture2D* This) { delete This; }

void SampleableTexture2DArray_Destroy(SampleableTexture2DArray* This) { delete This; }

void SampleableTexture3D_Destroy(SampleableTexture3D* This) { delete This; }

void SampleableTextureCube_Destroy(SampleableTextureCube* This) { delete This; }

Texture1D* Texture1D_Texture1D(int qualifiers, Type* format, Device* device, uint32_t width) {
  return new Texture1D(qualifiers, format, device->device, wgpu::TextureDimension::e1D,
                       {width, 1, 1});
}

void Texture1D_Destroy(Texture1D* This) { delete This; }

SampleableTexture1D* Texture1D_CreateSampleableView(Texture1D* This) {
  return new SampleableTexture1D(This->texture.CreateView());
}

Texture1D* Texture1D_CreateStorageView(Texture1D* This, uint32_t mipLevel) {
  return new Texture1D(This, wgpu::TextureViewDimension::e1D, 0, mipLevel);
}

void Texture1D_CopyFromBuffer(Texture1D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, 1, 1}, {origin, 0, 0});
}

Texture2D* Texture2D_Texture2D(int      qualifiers,
                               Type*    format,
                               Device*  device,
                               uint32_t width,
                               uint32_t height) {
  return new Texture2D(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                       {width, height, 1});
}

void Texture2D_Destroy(Texture2D* This) { delete This; }

SampleableTexture2D* Texture2D_CreateSampleableView(Texture2D* This) {
  return new SampleableTexture2D(This->texture.CreateView());
}

Texture2D* Texture2D_CreateRenderableView(Texture2D* This, uint32_t mipLevel) {
  return new Texture2D(This, wgpu::TextureViewDimension::e2D, 0, mipLevel);
}

Texture2D* Texture2D_CreateStorageView(Texture2D* This, uint32_t mipLevel) {
  return new Texture2D(This, wgpu::TextureViewDimension::e2D, 0, mipLevel);
}

uint32_t Texture2D_MinBufferWidth(Texture2D* This) { return This->MinBufferWidth(); }

void Texture2D_CopyFromBuffer(Texture2D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        height,
                              uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, 1},
                       {origin[0], origin[1], 0});
}

Texture2DArray* Texture2DArray_Texture2DArray(int      qualifiers,
                                              Type*    format,
                                              Device*  device,
                                              uint32_t width,
                                              uint32_t height,
                                              uint32_t layers) {
  return new Texture2DArray(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                            {width, height, layers});
}

void Texture2DArray_Destroy(Texture2DArray* This) { delete This; }

SampleableTexture2DArray* Texture2DArray_CreateSampleableView(Texture2DArray* This) {
  wgpu::TextureViewDescriptor desc;
  desc.dimension = wgpu::TextureViewDimension::e2DArray;
  return new SampleableTexture2DArray(This->texture.CreateView(&desc));
}

Texture2D* Texture2DArray_CreateRenderableView(Texture2DArray* This,
                                               uint32_t        layer,
                                               uint32_t        mipLevel) {
  return new Texture2D(This, wgpu::TextureViewDimension::e2D, layer, mipLevel);
}

Texture2DArray* Texture2DArray_CreateStorageView(Texture2DArray* This,
                                                 uint32_t        baseArrayLayer,
                                                 uint32_t        mipLevel) {
  return new Texture2DArray(This, wgpu::TextureViewDimension::e2DArray, baseArrayLayer, mipLevel);
}

uint32_t Texture2DArray_MinBufferWidth(Texture2DArray* This) { return This->MinBufferWidth(); }

void Texture2DArray_CopyFromBuffer(Texture2DArray* dest,
                                   CommandEncoder* encoder,
                                   Buffer*         source,
                                   uint32_t        width,
                                   uint32_t        height,
                                   uint32_t        layers,
                                   uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, layers},
                       {origin[0], origin[1], origin[2]});
}

Texture3D* Texture3D_Texture3D(int      qualifiers,
                               Type*    format,
                               Device*  device,
                               uint32_t width,
                               uint32_t height,
                               uint32_t depth) {
  return new Texture3D(qualifiers, format, device->device, wgpu::TextureDimension::e3D,
                       {width, height, depth});
}

void Texture3D_Destroy(Texture3D* This) { delete This; }

SampleableTexture3D* Texture3D_CreateSampleableView(Texture3D* This) {
  return new SampleableTexture3D(This->texture.CreateView());
}

Texture2D* Texture3D_CreateRenderableView(Texture3D* This, uint32_t depth, uint32_t mipLevel) {
  return new Texture2D(This, wgpu::TextureViewDimension::e2D, depth, mipLevel);
}

Texture3D* Texture3D_CreateStorageView(Texture2D* This, uint32_t baseDepth, uint32_t mipLevel) {
  return new Texture3D(This, wgpu::TextureViewDimension::e3D, baseDepth, mipLevel);
}

uint32_t Texture3D_MinBufferWidth(Texture3D* This) { return This->MinBufferWidth(); }

void Texture3D_CopyFromBuffer(Texture3D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        height,
                              uint32_t        depth,
                              uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, depth},
                       {origin[0], origin[1], origin[2]});
}

TextureCube* TextureCube_TextureCube(int      qualifiers,
                                     Type*    format,
                                     Device*  device,
                                     uint32_t width,
                                     uint32_t height) {
  return new TextureCube(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                         {width, height, 6});
}

void TextureCube_Destroy(TextureCube* This) { delete This; }

SampleableTextureCube* TextureCube_CreateSampleableView(TextureCube* This) {
  wgpu::TextureViewDescriptor desc;
  desc.dimension = wgpu::TextureViewDimension::Cube;
  return new SampleableTextureCube(This->texture.CreateView(&desc));
}

Texture2D* TextureCube_CreateRenderableView(TextureCube* This, int32_t face, int32_t mipLevel) {
  return new Texture2D(This, wgpu::TextureViewDimension::e2D, face, mipLevel);
}

Texture2D* TextureCube_CreateStorageView(TextureCube* This, int32_t face, int32_t mipLevel) {
  assert(!"unimplemented");
  return nullptr;
}

uint32_t TextureCube_MinBufferWidth(TextureCube* This) { return This->MinBufferWidth(); }

void TextureCube_CopyFromBuffer(TextureCube*    dest,
                                CommandEncoder* encoder,
                                Buffer*         source,
                                uint32_t        width,
                                uint32_t        height,
                                uint32_t        faces,
                                uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, faces},
                       {origin[0], origin[1], origin[2]});
}

Sampler* Sampler_Sampler(Device*     device,
                         AddressMode addressModeU,
                         AddressMode addressModeV,
                         AddressMode addressModeW,
                         FilterMode  magFilter,
                         FilterMode  minFilter,
                         FilterMode  mipmapFilter) {
  wgpu::SamplerDescriptor desc;
  desc.addressModeU = ToDawnAddressMode(addressModeU);
  desc.addressModeV = ToDawnAddressMode(addressModeV);
  desc.addressModeW = ToDawnAddressMode(addressModeW);
  desc.magFilter = ToDawnFilterMode(magFilter);
  desc.minFilter = ToDawnFilterMode(minFilter);
  desc.mipmapFilter = ToDawnMipmapFilterMode(mipmapFilter);
  wgpu::Sampler sampler = device->device.CreateSampler(&desc);
  return new Sampler(sampler);
}

void Sampler_Destroy(Sampler* This) { delete This; }

void CommandEncoder_CopyBufferToBuffer(CommandEncoder* encoder, Buffer* source, Buffer* dest) {
  encoder->encoder.CopyBufferToBuffer(source->buffer, 0, dest->buffer, 0, source->sizeInBytes);
}

#if TARGET_OS_IS_WASM
EM_ASYNC_JS(WGPUBufferMapAsyncStatus,
            JSMapSync,
            (WGPUBuffer bufferID, WGPUMapMode mode, int offset, int size),
            {
              const bufferWrapper = WebGPU.mgrBuffer.objects[bufferID];
              const buffer = bufferWrapper.object;

              const result = await buffer.mapAsync(mode, offset, size);
              bufferWrapper.mapMode = mode;
              bufferWrapper.onUnmap = [];
              return result;
            });
#endif

static Object* MapSync(wgpu::MapMode mapMode, Buffer* buffer) {
  WGPUBufferMapAsyncStatus status = WGPUBufferMapAsyncStatus_Unknown;
  if (buffer->mappedObject.ptr != nullptr) { return &buffer->mappedObject; }
  auto callback = [](WGPUBufferMapAsyncStatus status, void* userData) {
    *(WGPUBufferMapAsyncStatus*)userData = status;
  };
#if TARGET_OS_IS_WASM
  status =
      JSMapSync(buffer->buffer.Get(), static_cast<WGPUMapMode>(mapMode), 0, buffer->sizeInBytes);
#else
  buffer->buffer.MapAsync(mapMode, 0, buffer->sizeInBytes, callback, &status);
  while (status == WGPUBufferMapAsyncStatus_Unknown) {
    buffer->device.Tick();
  }
#endif
  Object result;
  if (status != WGPUBufferMapAsyncStatus_Success) { return &buffer->mappedObject; }
  if (!(mapMode & wgpu::MapMode::Write)) {
    const void* ptr = buffer->buffer.GetConstMappedRange();
    buffer->mappedObject.ptr = const_cast<void*>(ptr);
  } else {
    buffer->mappedObject.ptr = buffer->buffer.GetMappedRange();
  }
#if TARGET_OS_IS_WIN && TARGET_CPU_IS_X86
  ControlBlock* controlBlock =
      static_cast<ControlBlock*>(_aligned_malloc(sizeof(ControlBlock), 16));
#else
  ControlBlock* controlBlock = static_cast<ControlBlock*>(malloc(sizeof(ControlBlock)));
#endif
  controlBlock->strongRefs = controlBlock->weakRefs = 1;
  controlBlock->type = buffer->type;
  controlBlock->arrayLength = buffer->length;
  controlBlock->type = buffer->type;
  buffer->mappedObject.controlBlock = controlBlock;
  return &buffer->mappedObject;
}

Buffer* Buffer_Buffer_Device_uint(int      qualifiers,
                                  Type*    type,
                                  Device*  device,
                                  uint32_t dynamicArraySize) {
  wgpu::BufferDescriptor desc;
  desc.usage = toDawnBufferUsage(qualifiers);
  desc.size = type->GetSizeInBytes(dynamicArraySize);
  wgpu::Buffer b = device->device.CreateBuffer(&desc);
  return new Buffer(device->device, b, dynamicArraySize, desc.size, type);
}

Buffer* Buffer_Buffer_Device_T(int qualifiers, Type* type, Device* device, Object* object) {
  uint32_t size = 1;
  if (type->IsUnsizedArray()) { size = object->controlBlock->arrayLength; }
  Buffer* result = Buffer_Buffer_Device_uint(qualifiers, type, device, size);
  Buffer_SetData(result, object);
  return result;
}

Object* Buffer_MapRead(Buffer* buffer) { return MapSync(wgpu::MapMode::Read, buffer); }

Object* Buffer_MapWrite(Buffer* buffer) { return MapSync(wgpu::MapMode::Write, buffer); }

Object* Buffer_MapReadWrite(Buffer* buffer) {
  return MapSync(wgpu::MapMode::Read | wgpu::MapMode::Write, buffer);
}

void Buffer_Unmap(Buffer* buffer) {
  buffer->buffer.Unmap();
  ControlBlock* controlBlock = buffer->mappedObject.controlBlock;
  controlBlock->strongRefs = 0;
  if (controlBlock->weakRefs == 0) {
#if TARGET_OS_IS_WIN && TARGET_CPU_IS_X86
    _aligned_free(controlBlock);
#else
    free(controlBlock);
#endif
  }
  buffer->mappedObject.ptr = nullptr;
  buffer->mappedObject.controlBlock = nullptr;
}

void Buffer_SetData(Buffer* buffer, Object* object) {
  Type* type = object->controlBlock->type;
  assert(!type->IsPtr());
  size_t      size = type->GetSizeInBytes(object->controlBlock->arrayLength);
  wgpu::Queue queue = buffer->device.GetQueue();
  queue.WriteBuffer(buffer->buffer, 0, object->ptr, size);
}

void Buffer_Destroy(Buffer* This) { delete This; }

CommandEncoder* CommandEncoder_CommandEncoder(Device* device) {
  wgpu::CommandEncoderDescriptor desc;
  return new CommandEncoder(device->device.CreateCommandEncoder(&desc));
}

void CommandEncoder_Destroy(CommandEncoder* This) { delete This; }

void Queue_Submit(Queue* queue, CommandBuffer* commandBuffer) {
  queue->queue.Submit(1, &commandBuffer->commandBuffer);
}

ColorAttachment* ColorAttachment_ColorAttachment(int        qualifiers,
                                                 Type*      type,
                                                 Texture2D* texture,
                                                 LoadOp     loadOp,
                                                 StoreOp    storeOp,
                                                 float*     clearValue) {
  wgpu::RenderPassColorAttachment attachment;
  attachment.clearValue = {clearValue[0], clearValue[1], clearValue[2], clearValue[3]};
  attachment.loadOp = ToDawnLoadOp(loadOp);
  attachment.storeOp = ToDawnStoreOp(storeOp);
  attachment.view = texture->view;
  return new ColorAttachment(attachment);
}

void ColorAttachment_Destroy(ColorAttachment* This) { delete This; }

DepthStencilAttachment* DepthStencilAttachment_DepthStencilAttachment(int        qualifiers,
                                                                      Type*      type,
                                                                      Texture2D* texture,
                                                                      LoadOp     depthLoadOp,
                                                                      StoreOp    depthStoreOp,
                                                                      float      depthClearValue,
                                                                      LoadOp     stencilLoadOp,
                                                                      StoreOp    stencilStoreOp,
                                                                      int stencilClearValue) {
  wgpu::RenderPassDepthStencilAttachment attachment;
  attachment.view = texture->view;
  attachment.depthLoadOp = ToDawnLoadOp(depthLoadOp);
  attachment.depthStoreOp = ToDawnStoreOp(depthStoreOp);
  attachment.depthClearValue = depthClearValue;
  attachment.stencilLoadOp = ToDawnLoadOp(stencilLoadOp);
  attachment.stencilStoreOp = ToDawnStoreOp(stencilStoreOp);
  attachment.stencilClearValue = stencilClearValue;
  return new DepthStencilAttachment(attachment);
}

void DepthStencilAttachment_Destroy(DepthStencilAttachment* This) { delete This; }

RenderPass* RenderPass_RenderPass_CommandEncoder_T(int             qualifiers,
                                                   Type*           type,
                                                   CommandEncoder* encoder,
                                                   Object*         data) {
  Type* objectType = data->controlBlock->type;
  assert(objectType->IsClass());
  ClassType*   classType = static_cast<ClassType*>(objectType);
  PipelineData pipelineData;
  ExtractPipelineData(classType, data->ptr, &pipelineData);

  wgpu::RenderPassDescriptor desc;
  desc.colorAttachmentCount = pipelineData.colorAttachments.size();
  desc.colorAttachments = pipelineData.colorAttachments.data();
  if (pipelineData.depthStencilAttachment.view != nullptr) {
    desc.depthStencilAttachment = &pipelineData.depthStencilAttachment;
  }
  auto result = encoder->encoder.BeginRenderPass(&desc);
  pipelineData.Set(result);
  return new RenderPass(result);
}

RenderPass* RenderPass_RenderPass_RenderPass(int qualifiers, Type* type, RenderPass* parent) {
  return new RenderPass(parent->encoder);
}

void RenderPass_Set(RenderPass* This, Object* data) {
  PipelineData pipelineData;
  Type*        objectType = data->controlBlock->type;
  assert(objectType->IsClass());
  ClassType* classType = static_cast<ClassType*>(objectType);
  ExtractPipelineData(classType, data->ptr, &pipelineData);
  pipelineData.Set(This->encoder);
}

void RenderPass_SetPipeline(RenderPass* This, RenderPipeline* pipeline) {
  This->encoder.SetPipeline(pipeline->pipeline);
}

void RenderPass_Draw(RenderPass* This,
                     uint32_t    vertexCount,
                     uint32_t    instanceCount,
                     uint32_t    firstVertex,
                     uint32_t    firstInstance) {
  This->encoder.Draw(vertexCount, instanceCount, firstVertex, firstInstance);
}

void RenderPass_DrawIndexed(RenderPass* This,
                            uint32_t    indexCount,
                            uint32_t    instanceCount,
                            uint32_t    firstVertex,
                            uint32_t    baseVertex,
                            uint32_t    firstInstance) {
  This->encoder.DrawIndexed(indexCount, instanceCount, firstVertex, baseVertex, firstInstance);
}

void RenderPass_End(RenderPass* This) { This->encoder.End(); }

void RenderPass_Destroy(RenderPass* This) { delete This; }

ComputePass* ComputePass_ComputePass(int             qualifiers,
                                     Type*           type,
                                     CommandEncoder* encoder,
                                     Object*         data) {
  PipelineData pipelineData;
  if (data && data->controlBlock) {
    Type* objectType = data->controlBlock->type;
    assert(objectType->IsClass());
    ClassType* classType = static_cast<ClassType*>(objectType);
    ExtractPipelineData(classType, data->ptr, &pipelineData);
  }
  wgpu::ComputePassDescriptor desc;
  auto                        passEncoder = encoder->encoder.BeginComputePass(&desc);
  pipelineData.Set(passEncoder);
  return new ComputePass(passEncoder);
}

void ComputePass_SetPipeline(ComputePass* This, ComputePipeline* pipeline) {
  This->encoder.SetPipeline(pipeline->pipeline);
}

void ComputePass_Set(ComputePass* This, Object* data) {
  PipelineData pipelineData;
  Type*        objectType = data->controlBlock->type;
  assert(objectType->IsClass());
  ClassType* classType = static_cast<ClassType*>(objectType);
  ExtractPipelineData(classType, data->ptr, &pipelineData);
  pipelineData.Set(This->encoder);
}

void ComputePass_Dispatch(ComputePass* This,
                          uint32_t     workgroupCountX,
                          uint32_t     workgroupCountY,
                          uint32_t     workgroupCountZ) {
  This->encoder.DispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
}

void ComputePass_End(ComputePass* This) { This->encoder.End(); }

void ComputePass_Destroy(ComputePass* This) { delete This; }

CommandBuffer* CommandEncoder_Finish(CommandEncoder* encoder) {
  return new CommandBuffer(encoder->encoder.Finish());
}

void CommandBuffer_Destroy(CommandBuffer* This) { delete This; }

Texture2D* SwapChain_GetCurrentTexture(SwapChain* swapChain) {
  return new Texture2D(swapChain->swapChain.GetCurrentTexture(),
                       swapChain->swapChain.GetCurrentTexture().CreateView(), swapChain->extent,
                       swapChain->format);
}

#if !TARGET_OS_IS_MAC
#if !TARGET_OS_IS_WASM
void SwapChain_Present(SwapChain* swapChain) { swapChain->swapChain.Present(); }
#endif

void SwapChain_Destroy(SwapChain* This) { delete This; }
#endif

float Math_rand() { return (float)(rand() % 100) / 100.0f; }

void Math_Destroy(Math* This) {}

void System_Print(Object* buffer) {
  fwrite(buffer->ptr, 1, buffer->controlBlock->arrayLength, stdout);
}

void System_PrintLine(Object* buffer) {
  fwrite(buffer->ptr, 1, buffer->controlBlock->arrayLength, stdout);
  fwrite("\n", 1, 1, stdout);
}

void System_Abort() { abort(); }

void System_Destroy(System* This) {}

void Event_Destroy(Event* This) { delete This; }

};  // namespace Toucan
