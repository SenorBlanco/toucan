// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <assert.h>
#include <stdio.h>

#include <cstring>
#include <unordered_map>

#if TARGET_IS_WASM
#include <emscripten.h>
#endif

#include <webgpu/webgpu_cpp.h>

#include <ast/native_class.h>
#include <ast/type.h>
#include "api_internal.h"

namespace Toucan {

namespace {

uint32_t BytesPerPixel(wgpu::TextureFormat format) {
  switch (format) {
    case wgpu::TextureFormat::RGBA8Unorm:
    case wgpu::TextureFormat::RGBA8Snorm:
    case wgpu::TextureFormat::RGBA8Uint:
    case wgpu::TextureFormat::RGBA8Sint:
    case wgpu::TextureFormat::BGRA8Unorm: return 4;
    default: assert(!"unknown Format"); return 0;
  }
}

static wgpu::TextureUsage ToDawnTextureUsage(int qualifiers) {
  wgpu::TextureUsage result = wgpu::TextureUsage::CopySrc | wgpu::TextureUsage::CopyDst;

  if (qualifiers & Type::Qualifier::Storage) { result |= wgpu::TextureUsage::StorageBinding; }
  if (qualifiers & Type::Qualifier::Sampleable) { result |= wgpu::TextureUsage::TextureBinding; }
  if (qualifiers & Type::Qualifier::Renderable) { result |= wgpu::TextureUsage::RenderAttachment; }
  return result;
}

}  // namespace

struct TextureView {
  TextureView(wgpu::TextureView v) : view(v) {}
  wgpu::TextureView view;
};

struct SampleableTexture1D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2DArray : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture3D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTextureCube : public TextureView {
  using TextureView::TextureView;
};

struct Texture {
  Texture(wgpu::Texture t, const wgpu::Extent3D& s, wgpu::TextureFormat f)
      : texture(t), size(s), format(f) {}
  Texture(int qualifiers, Type* pixelFormat, wgpu::Device device, wgpu::TextureDimension d, wgpu::Extent3D s) {
    wgpu::TextureDescriptor desc;
    desc.usage = ToDawnTextureUsage(qualifiers);
    desc.size = size = s;
    desc.format = format = ToDawnTextureFormat(pixelFormat);
    desc.dimension = d;
    texture = device.CreateTexture(&desc);
  }
  uint32_t MinBufferWidth() {
    uint32_t bytesPerPixel = BytesPerPixel(format);
    return (((size.width * bytesPerPixel + 255) >> 8) << 8) / bytesPerPixel;
  }

  void CopyFromBuffer(wgpu::CommandEncoder encoder,
                      wgpu::Buffer         source,
                      wgpu::Extent3D       extent,
                      wgpu::Origin3D       origin) {
    wgpu::ImageCopyBuffer sourceICB;
    sourceICB.buffer = source;
    sourceICB.layout.bytesPerRow = MinBufferWidth() * BytesPerPixel(format);
    sourceICB.layout.rowsPerImage = size.height;
    wgpu::ImageCopyTexture destICT;
    destICT.texture = texture;
    destICT.origin = origin;
    encoder.CopyBufferToTexture(&sourceICB, &destICT, &extent);
  }
  wgpu::Texture       texture;
  wgpu::Extent3D      size;
  wgpu::TextureFormat format;
};

struct Texture1D : public Texture {
  using Texture::Texture;
};
struct Texture2D : public Texture {
  using Texture::Texture;
};
struct Texture2DArray : public Texture {
  using Texture::Texture;
};
struct Texture3D : public Texture {
  using Texture::Texture;
};
struct TextureCube : public Texture {
  using Texture::Texture;
};

struct Sampler {
  Sampler(wgpu::Sampler s) : sampler(s) {}
  wgpu::Sampler sampler;
};

struct Buffer {
  Buffer(wgpu::Device d, wgpu::Buffer b, int l, int s, Type* t)
      : device(d), buffer(b), length(l), sizeInBytes(s), type(t) {}
  wgpu::Device device;
  wgpu::Buffer buffer;
  int          length;
  int          sizeInBytes;
  Type*        type;
  Object       mappedObject = {nullptr, nullptr};
};

struct RenderPipeline {
  RenderPipeline(wgpu::RenderPipeline p) : pipeline(p) {}
  wgpu::RenderPipeline pipeline;
};

struct ComputePipeline {
  ComputePipeline(wgpu::ComputePipeline p) : pipeline(p) {}
  wgpu::ComputePipeline pipeline;
};

wgpu::TextureView CreateRenderable2DView(Texture* texture) {
  wgpu::TextureViewDescriptor desc;
  desc.format = texture->format;
  desc.dimension = wgpu::TextureViewDimension::e2D;
  desc.mipLevelCount = 1;
  desc.arrayLayerCount = 1;
  return texture->texture.CreateView(&desc);
}

wgpu::TextureFormat ToDawnTextureFormat(Type* format) {
  assert(format->IsClass());
  auto classType = static_cast<ClassType*>(format);
  if (classType->GetName() == "RGBA8unorm") {
    return wgpu::TextureFormat::RGBA8Unorm;
  } else if (classType->GetName() == "BGRA8unorm") {
    return wgpu::TextureFormat::BGRA8Unorm;
  } else if (classType->GetName() == "RGBA8snorm") {
    return wgpu::TextureFormat::RGBA8Snorm;
  } else if (classType->GetName() == "Depth24Plus") {
    return wgpu::TextureFormat::Depth24Plus;
  } else if (classType->GetName() == "PreferredSwapChainFormat") {
    return GetPreferredSwapChainFormat();
  } else {
    assert(!"unknown Format");
    return wgpu::TextureFormat::RGBA8Unorm;
  }
}

wgpu::TextureSampleType ToDawnTextureSampleType(ClassType* type) {
  Type* arg = type->GetTemplateArgs()[0];
  if (arg->IsFloat()) {
    return wgpu::TextureSampleType::Float;
  } else if (arg->IsInt()) {
    return wgpu::TextureSampleType::Sint;
  } else if (arg->IsUInt()) {
    return wgpu::TextureSampleType::Uint;
  } else {
    assert(!"unknown texture sample type");
    return wgpu::TextureSampleType::Float;
  }
}

static wgpu::VertexFormat toDawnVertexFormat(Type* type) {
  if (type->IsVector()) {
    VectorType* v = static_cast<VectorType*>(type);
    if (v->GetComponentType()->IsInt()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Sint32x2;
        case 3: return wgpu::VertexFormat::Sint32x3;
        case 4: return wgpu::VertexFormat::Sint32x4;
      }
    } else if (v->GetComponentType()->IsFloat()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Float32x2;
        case 3: return wgpu::VertexFormat::Float32x3;
        case 4: return wgpu::VertexFormat::Float32x4;
      }
    } else if (v->GetComponentType()->IsUInt()) {
      switch (v->GetLength()) {
        case 2: return wgpu::VertexFormat::Uint32x2;
        case 3: return wgpu::VertexFormat::Uint32x3;
        case 4: return wgpu::VertexFormat::Uint32x4;
      }
    }
  } else if (type->IsInt()) {
    return wgpu::VertexFormat::Sint32;
  } else if (type->IsFloat()) {
    return wgpu::VertexFormat::Float32;
  } else if (type->IsUInt()) {
    return wgpu::VertexFormat::Uint32;
  }
  assert(!"invalid vertex format");
  return wgpu::VertexFormat::Uint8x2;
}

static wgpu::AddressMode ToDawnAddressMode(AddressMode mode) {
  switch (mode) {
    case AddressMode::Repeat: return wgpu::AddressMode::Repeat;
    case AddressMode::MirrorRepeat: return wgpu::AddressMode::MirrorRepeat;
    case AddressMode::ClampToEdge: return wgpu::AddressMode::ClampToEdge;
  }
  assert(!"unknown address mode");
  return wgpu::AddressMode::Repeat;
}

static wgpu::FilterMode ToDawnFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::FilterMode::Nearest;
    case FilterMode::Linear: return wgpu::FilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::FilterMode::Nearest;
}

static wgpu::MipmapFilterMode ToDawnMipmapFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::MipmapFilterMode::Nearest;
    case FilterMode::Linear: return wgpu::MipmapFilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::MipmapFilterMode::Nearest;
}

// FIXME: this should handle a mask, properly
static wgpu::BufferUsage toDawnBufferUsage(int qualifiers) {
  if (qualifiers == 0) { qualifiers = Type::Qualifier::WriteOnly; }
  wgpu::BufferUsage result = wgpu::BufferUsage::None;
  bool              gpu = false;
  if (qualifiers & Type::Qualifier::Index) {
    result |= wgpu::BufferUsage::Index;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Vertex) {
    result |= wgpu::BufferUsage::Vertex;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Uniform) {
    result |= wgpu::BufferUsage::Uniform;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Storage) {
    result |= wgpu::BufferUsage::Storage;
    gpu = true;
  }
  if (gpu) {
    result |= wgpu::BufferUsage::CopyDst;
    // F*XME: handle readonly, writeonly, readwrite storage
  } else {
    if (qualifiers & (Type::Qualifier::ReadOnly | Type::Qualifier::ReadWrite)) {
      result |= wgpu::BufferUsage::MapRead | wgpu::BufferUsage::CopyDst;
    }
    if (qualifiers & (Type::Qualifier::WriteOnly | Type::Qualifier::ReadWrite)) {
      result |= wgpu::BufferUsage::MapWrite | wgpu::BufferUsage::CopySrc;
    }
  }
  return result;
}

static wgpu::PrimitiveTopology toDawnPrimitiveTopology(PrimitiveTopology type) {
  switch (type) {
    case PointList: return wgpu::PrimitiveTopology::PointList;
    case LineList: return wgpu::PrimitiveTopology::LineList;
    case LineStrip: return wgpu::PrimitiveTopology::LineStrip;
    case TriangleList: return wgpu::PrimitiveTopology::TriangleList;
    case TriangleStrip: return wgpu::PrimitiveTopology::TriangleStrip;
    default: assert(!"unknown PrimitiveTopology"); return wgpu::PrimitiveTopology::PointList;
  }
}

wgpu::VertexBufferLayout toDawnVertexBufferLayout(Type*                               vertexInput,
                                                  std::vector<wgpu::VertexAttribute>* vaDescs) {
  if (vertexInput->IsClass()) {
    auto               classType = static_cast<ClassType*>(vertexInput);
    const FieldVector& fields = classType->GetFields();
    for (int i = 0; i < fields.size(); i++) {
      wgpu::VertexAttribute vaDesc;
      vaDesc.shaderLocation = i;
      vaDesc.offset = fields[i]->offset;
      vaDesc.format = toDawnVertexFormat(fields[i]->type);
      vaDescs->push_back(vaDesc);
    }
  } else {
    wgpu::VertexAttribute vaDesc;
    vaDesc.shaderLocation = 0;
    vaDesc.offset = 0;
    vaDesc.format = toDawnVertexFormat(vertexInput);
    vaDescs->push_back(vaDesc);
  }
  wgpu::VertexBufferLayout input;
  input.arrayStride = vertexInput->GetSizeInBytes();
  input.attributeCount = vaDescs->size();
  input.attributes = vaDescs->data();
  return input;
}

wgpu::BufferBindingType toDawnBufferBindingType(int qualifiers) {
  if (qualifiers & Type::Qualifier::Uniform) { return wgpu::BufferBindingType::Uniform; }
  if (qualifiers & Type::Qualifier::Storage) {
    if (qualifiers & Type::Qualifier::ReadOnly) {
      return wgpu::BufferBindingType::ReadOnlyStorage;
    } else {
      return wgpu::BufferBindingType::Storage;
    }
  }
  assert(!"invalid qualifiers for buffer binding");
  return wgpu::BufferBindingType::Undefined;
}

// FIXME: store this in Device.
std::unordered_map<Type*, wgpu::BindGroupLayout> bindGroupLayoutCache;

static wgpu::BindGroupLayoutEntry CreateBindGroupLayoutEntry(uint32_t binding,
                                                             Type*    type,
                                                             int      qualifiers) {
  assert(!type->IsPtr());
  if (!type->IsClass()) {
    assert(!"invalid field type in bind group (not class)");
    return {};
  }
  ClassType*                 classType = static_cast<ClassType*>(type);
  wgpu::BindGroupLayoutEntry entry;
  // FIXME: get visibilty from qualifiers
  entry.binding = binding;
  if (qualifiers & Type::Qualifier::Storage) {
    entry.visibility = wgpu::ShaderStage::Compute | wgpu::ShaderStage::Fragment;
  } else {
    entry.visibility =
        wgpu::ShaderStage::Vertex | wgpu::ShaderStage::Fragment | wgpu::ShaderStage::Compute;
  }
  ClassType* templ = classType->GetTemplate();
  if (templ == NativeClass::Buffer) {
    entry.buffer.type = toDawnBufferBindingType(qualifiers);
  } else if (templ == NativeClass::SampleableTexture1D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e1D;
  } else if (templ == NativeClass::SampleableTexture2D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2D;
  } else if (templ == NativeClass::SampleableTexture3D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e3D;
  } else if (templ == NativeClass::SampleableTexture2DArray) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2DArray;
  } else if (templ == NativeClass::SampleableTextureCube) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType);
    entry.texture.viewDimension = wgpu::TextureViewDimension::Cube;
  } else if (classType == NativeClass::Sampler) {
    entry.sampler.type = wgpu::SamplerBindingType::Filtering;
  } else {
    assert(!"invalid field type in bind group");
  }
  return entry;
}

static void CreateBindGroupLayoutEntries(ClassType*                               classType,
                                         int                                      qualifiers,
                                         std::vector<wgpu::BindGroupLayoutEntry>* entries) {
  if (classType->GetParent()) {
    CreateBindGroupLayoutEntries(classType->GetParent(), qualifiers, entries);
  }
  if (classType->IsNative()) {
    auto entry = CreateBindGroupLayoutEntry(0, classType, qualifiers);
    entries->push_back(entry);
  } else {
    uint32_t bindingIndex = 0;
    for (const auto& field : classType->GetFields()) {
      assert(field->type->IsPtr());
      Type* type = static_cast<PtrType*>(field->type)->GetBaseType();
      type = type->GetUnqualifiedType(&qualifiers);
      auto entry = CreateBindGroupLayoutEntry(bindingIndex, type, qualifiers);
      bindingIndex++;
      entries->push_back(entry);
    }
  }
}

static wgpu::BindGroupLayout GetOrCreateBindGroupLayout(Device* device, Type* type) {
  assert(!type->IsPtr());
  if (auto layout = bindGroupLayoutCache[type]) { return layout; }
  int qualifiers;
  type = type->GetUnqualifiedType(&qualifiers);
  std::vector<wgpu::BindGroupLayoutEntry> entries;
  assert(type->IsClass());
  CreateBindGroupLayoutEntries(static_cast<ClassType*>(type), qualifiers, &entries);
  wgpu::BindGroupLayoutDescriptor desc;
  desc.entryCount = entries.size();
  desc.entries = entries.data();
  auto layout = device->device.CreateBindGroupLayout(&desc);
  bindGroupLayoutCache[type] = layout;
  return layout;
}

wgpu::BindGroupEntry CreateBindGroupEntry(Type* type, int binding, Object* object) {
  wgpu::BindGroupEntry entry;
  entry.binding = binding;
  entry.buffer = nullptr;
  entry.sampler = nullptr;
  entry.textureView = nullptr;
  if (type->IsPtr()) { type = static_cast<PtrType*>(type)->GetBaseType(); }
  int qualifiers = 0;
  type = type->GetUnqualifiedType(&qualifiers);
  assert(type->IsClass() && "bind group entry must be of class type");
  ClassType* c = static_cast<ClassType*>(type);
  ClassType* templ = c->GetTemplate();
  if (templ == NativeClass::SampleableTexture1D || templ == NativeClass::SampleableTexture2D ||
      templ == NativeClass::SampleableTexture3D || templ == NativeClass::SampleableTexture2DArray ||
      templ == NativeClass::SampleableTextureCube) {
    TextureView* textureView = static_cast<TextureView*>(object->ptr);
    entry.textureView = textureView->view;
  } else if (c == NativeClass::Sampler) {
    Sampler* sampler = static_cast<Sampler*>(object->ptr);
    entry.sampler = sampler->sampler;
  } else if (templ == NativeClass::Buffer) {
    Buffer* buffer = static_cast<Buffer*>(object->ptr);
    entry.buffer = buffer->buffer;
    entry.size = buffer->sizeInBytes;
  }
  return entry;
}

struct BindGroup {
  BindGroup(wgpu::BindGroup b) : bindGroup(b) {}
  wgpu::BindGroup bindGroup;
};

struct BindGroupLayout {
  BindGroupLayout(wgpu::BindGroupLayout b) : bindGroupLayout(b) {}
  wgpu::BindGroupLayout bindGroupLayout;
};

struct RenderPassEncoder {
  RenderPassEncoder(wgpu::RenderPassEncoder e) : encoder(e) {}
  wgpu::RenderPassEncoder encoder;
};

struct ComputePassEncoder {
  ComputePassEncoder(wgpu::ComputePassEncoder e) : encoder(e) {}
  wgpu::ComputePassEncoder encoder;
};

struct CommandEncoder {
  CommandEncoder(wgpu::CommandEncoder e) : encoder(e) {}
  wgpu::CommandEncoder encoder;
};

struct CommandBuffer {
  CommandBuffer(wgpu::CommandBuffer cb) : commandBuffer(cb) {}
  wgpu::CommandBuffer commandBuffer;
};

struct Queue {
  Queue(wgpu::Queue q) : queue(q) {}
  wgpu::Queue queue;
};

Queue* Device_GetQueue(Device* device) { return new Queue(device->device.GetQueue()); }

void Device_Destroy(Device* This) { delete This; }

void Queue_Destroy(Queue* This) { delete This; }

wgpu::ShaderModule createShaderModule(Device* device, Method* m) {
  wgpu::ShaderModuleDescriptor desc;
#if TARGET_IS_WASM
  wgpu::ShaderModuleWGSLDescriptor wgslDesc;
  wgslDesc.code = m->wgsl.data();
  desc.nextInChain = &wgslDesc;
#else
  wgpu::ShaderModuleSPIRVDescriptor spirvDesc;
  spirvDesc.codeSize = m->spirv.size();
  spirvDesc.code = m->spirv.data();
  desc.nextInChain = &spirvDesc;
#endif
  return device->device.CreateShaderModule(&desc);
}

static void CreatePipelineLayout(ClassType*                          classType,
                                 Device*                             device,
                                 std::vector<wgpu::BindGroupLayout>* layouts) {
  if (classType->GetParent()) { CreatePipelineLayout(classType->GetParent(), device, layouts); }
  for (const auto& field : classType->GetFields()) {
    Type* type = field->type;
    if (type->IsPtr()) { type = static_cast<PtrType*>(type)->GetBaseType(); }
    wgpu::BindGroupLayout layout = GetOrCreateBindGroupLayout(device, type);
    layouts->push_back(layout);
  }
}

wgpu::PipelineLayout CreatePipelineLayout(ClassType* classType, Device* device) {
  wgpu::PipelineLayoutDescriptor     desc;
  std::vector<wgpu::BindGroupLayout> layouts;
  CreatePipelineLayout(classType, device, &layouts);
  desc.bindGroupLayoutCount = layouts.size();
  desc.bindGroupLayouts = layouts.data();
  return device->device.CreatePipelineLayout(&desc);
}

RenderPipeline* RenderPipeline_RenderPipeline(int               qualifiers,
                                              Type*             pipelineLayout,
                                              Device*           device,
                                              Object*           depthStencil,
                                              PrimitiveTopology primitiveTopology) {
  if (!pipelineLayout->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(pipelineLayout);
  wgpu::ShaderModule vertexShader, fragmentShader;
  ClassType*         vertexInput;
  for (auto& method : classType->GetMethods()) {
    if (method->shaderType == ShaderType::Vertex) {
      if (vertexShader) {
        assert(!"more than one vertex shader specified");
        return nullptr;
      }
      vertexShader = createShaderModule(device, method.get());
      assert(method->formalArgList.size() == 1);
      vertexInput = static_cast<ClassType*>(method->formalArgList[0]->type);
    } else if (method->shaderType == ShaderType::Fragment) {
      if (fragmentShader) {
        assert(!"more than one fragment shader specified");
        return nullptr;
      }
      fragmentShader = createShaderModule(device, method.get());
    }
  }
  std::vector<wgpu::VertexAttribute> vaDescs;
  wgpu::VertexBufferLayout           vbDesc = toDawnVertexBufferLayout(vertexInput, &vaDescs);
  wgpu::VertexState                  vertexState;
  vertexState.module = vertexShader;
  vertexState.entryPoint = "main";
  vertexState.bufferCount = 1;
  vertexState.buffers = &vbDesc;
  wgpu::RenderPipelineDescriptor rpDesc;
  wgpu::ColorTargetState         colorTargetState;
  colorTargetState.format = GetPreferredSwapChainFormat();  // FIXME
  wgpu::DepthStencilState depthStencilState;
  if (depthStencil->ptr) {
    Type* type = depthStencil->controlBlock->type;
    assert(type->IsClass());
    ClassType*  classType = static_cast<ClassType*>(type);
    const auto& templateArgs = classType->GetTemplateArgs();
    assert(templateArgs.size() == 1);
    depthStencilState.format = ToDawnTextureFormat(templateArgs[0]);
    depthStencilState.depthWriteEnabled = true;
    depthStencilState.depthCompare = wgpu::CompareFunction::Less;
  }
  wgpu::FragmentState fragmentState;
  fragmentState.module = fragmentShader;
  fragmentState.entryPoint = "main";
  fragmentState.constants = nullptr;
  fragmentState.targetCount = 1;
  fragmentState.targets = &colorTargetState;
  wgpu::PrimitiveState primitiveState;
  rpDesc.layout = CreatePipelineLayout(classType, device);
  rpDesc.vertex = vertexState;
  rpDesc.fragment = &fragmentState;
  rpDesc.primitive.topology = toDawnPrimitiveTopology(primitiveTopology);
  if (depthStencil->ptr) { rpDesc.depthStencil = &depthStencilState; }
  return new RenderPipeline(device->device.CreateRenderPipeline(&rpDesc));
}

void RenderPipeline_Destroy(RenderPipeline* This) { delete This; }

ComputePipeline* ComputePipeline_ComputePipeline(int     qualifiers,
                                                 Type*   computeLayout,
                                                 Device* device) {
  if (!computeLayout->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(computeLayout);
  wgpu::ShaderModule computeShader;
  ClassType*         vertexInput;
  for (auto& method : classType->GetMethods()) {
    if (method->shaderType == ShaderType::Compute) {
      if (computeShader) {
        assert(!"more than one compute shader specified");
        return nullptr;
      }
      computeShader = createShaderModule(device, method.get());
    }
  }
  wgpu::ProgrammableStageDescriptor computeState;
  computeState.module = computeShader;
  computeState.entryPoint = "main";
  wgpu::ComputePipelineDescriptor cpDesc;
  cpDesc.layout = CreatePipelineLayout(classType, device);
  cpDesc.compute = computeState;
  return new ComputePipeline(device->device.CreateComputePipeline(&cpDesc));
}

void ComputePipeline_Destroy(ComputePipeline* This) { delete This; }

BindGroup* BindGroup_BindGroup(Device* device, Object* data) {
  Type* type = data->controlBlock->type->GetUnqualifiedType();
  assert(type->IsClass() && "bind group argument must be a class type");
  ClassType*                        classType = static_cast<ClassType*>(type);
  wgpu::BindGroupDescriptor         desc;
  std::vector<wgpu::BindGroupEntry> entries;
  if (classType->IsNative()) {
    auto entry = CreateBindGroupEntry(data->controlBlock->type, 0, data);
    desc.entryCount = 1;
    desc.entries = &entry;
    desc.layout = GetOrCreateBindGroupLayout(device, data->controlBlock->type);
  } else {
    desc.entryCount = classType->GetFields().size();
    for (int i = 0; i < desc.entryCount; i++) {
      Field* field = classType->GetFields()[i].get();
      Object object = *reinterpret_cast<Object*>((uint8_t*)data->ptr + field->offset);
      entries.push_back(CreateBindGroupEntry(field->type, i, &object));
    }
    desc.entries = entries.data();
    desc.layout = GetOrCreateBindGroupLayout(device, classType);
  }
  return new BindGroup(device->device.CreateBindGroup(&desc));
}

void BindGroup_Destroy(BindGroup* This) { delete This; }

void SampleableTexture1D_Destroy(SampleableTexture1D* This) { delete This; }

void SampleableTexture2D_Destroy(SampleableTexture2D* This) { delete This; }

void SampleableTexture2DArray_Destroy(SampleableTexture2DArray* This) { delete This; }

void SampleableTexture3D_Destroy(SampleableTexture3D* This) { delete This; }

void SampleableTextureCube_Destroy(SampleableTextureCube* This) { delete This; }

Texture1D* Texture1D_Texture1D(int qualifiers, Type* format, Device* device, uint32_t width) {
  return new Texture1D(qualifiers, format, device->device, wgpu::TextureDimension::e1D, {width, 1, 1});
}

void Texture1D_Destroy(Texture1D* This) { delete This; }

SampleableTexture1D* Texture1D_CreateSampleableView(Texture1D* This) {
  return new SampleableTexture1D(This->texture.CreateView());
}

Texture1D* Texture1D_CreateStorageView(Texture1D* This) {
  assert(!"unimplemented");
  return nullptr;
}

void Texture1D_CopyFromBuffer(Texture1D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, 1, 1}, {origin, 0, 0});
}

Texture2D* Texture2D_Texture2D(int      qualifiers,
                               Type*    format,
                               Device*  device,
                               uint32_t width,
                               uint32_t height) {
  return new Texture2D(qualifiers, format, device->device, wgpu::TextureDimension::e2D, {width, height, 1});
}

void Texture2D_Destroy(Texture2D* This) { delete This; }

SampleableTexture2D* Texture2D_CreateSampleableView(Texture2D* This) {
  return new SampleableTexture2D(This->texture.CreateView());
}

Texture2D* Texture2D_CreateRenderableView(Texture2D* This) {
  assert(!"unimplemented");
  return nullptr;
}

Texture2D* Texture2D_CreateStorageView(Texture2D* This) {
  assert(!"unimplemented");
  return nullptr;
}

uint32_t Texture2D_MinBufferWidth(Texture2D* This) { return This->MinBufferWidth(); }

void Texture2D_CopyFromBuffer(Texture2D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        height,
                              uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, 1},
                       {origin[0], origin[1], 0});
}

Texture2DArray* Texture2DArray_Texture2DArray(int      qualifiers,
                                              Type*    format,
                                              Device*  device,
                                              uint32_t width,
                                              uint32_t height,
                                              uint32_t layers) {
  return new Texture2DArray(qualifiers, format, device->device, wgpu::TextureDimension::e2D, {width, height, layers});
}

void Texture2DArray_Destroy(Texture2DArray* This) { delete This; }

SampleableTexture2DArray* Texture2DArray_CreateSampleableView(Texture2DArray* This) {
  wgpu::TextureViewDescriptor desc;
  desc.dimension = wgpu::TextureViewDimension::e2DArray;
  return new SampleableTexture2DArray(This->texture.CreateView(&desc));
}

Texture2DArray* Texture2DArray_CreateRenderableView(Texture2DArray* This) {
  assert(!"unimplemented");
  return nullptr;
}

Texture2DArray* Texture2DArray_CreateStorageView(Texture2DArray* This) {
  assert(!"unimplemented");
  return nullptr;
}

uint32_t Texture2DArray_MinBufferWidth(Texture2DArray* This) { return This->MinBufferWidth(); }

void Texture2DArray_CopyFromBuffer(Texture2DArray* dest,
                                   CommandEncoder* encoder,
                                   Buffer*         source,
                                   uint32_t        width,
                                   uint32_t        height,
                                   uint32_t        layers,
                                   uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, layers},
                       {origin[0], origin[1], origin[2]});
}

Texture3D* Texture3D_Texture3D(int      qualifiers,
                               Type*    format,
                               Device*  device,
                               uint32_t width,
                               uint32_t height,
                               uint32_t depth) {
  return new Texture3D(qualifiers, format, device->device, wgpu::TextureDimension::e3D, {width, height, depth});
}

void Texture3D_Destroy(Texture3D* This) { delete This; }

SampleableTexture3D* Texture3D_CreateSampleableView(Texture3D* This) {
  return new SampleableTexture3D(This->texture.CreateView());
}

Texture3D* Texture3D_CreateRenderableView(Texture3D* This, uint32_t depth, uint32_t mipLevel) {
  assert(!"unimplemented");
  return nullptr;
}

Texture3D* Texture3D_CreateStorageView(Texture2D* This, uint32_t depth, uint32_t mipLevel) {
  assert(!"unimplemented");
  return nullptr;
}

uint32_t Texture3D_MinBufferWidth(Texture3D* This) { return This->MinBufferWidth(); }

void Texture3D_CopyFromBuffer(Texture3D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        height,
                              uint32_t        depth,
                              uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, depth},
                       {origin[0], origin[1], origin[2]});
}

TextureCube* TextureCube_TextureCube(int      qualifiers,
                                     Type*    format,
                                     Device*  device,
                                     uint32_t width,
                                     uint32_t height) {
  return new TextureCube(qualifiers, format, device->device, wgpu::TextureDimension::e2D, {width, height, 6});
}

void TextureCube_Destroy(TextureCube* This) { delete This; }

SampleableTextureCube* TextureCube_CreateSampleableView(TextureCube* This) {
  wgpu::TextureViewDescriptor desc;
  desc.dimension = wgpu::TextureViewDimension::Cube;
  return new SampleableTextureCube(This->texture.CreateView(&desc));
}

Texture2D* TextureCube_CreateRenderableView(TextureCube* This, int32_t face, int32_t mipLevel) {
  assert(!"unimplemented");
  return nullptr;
}

Texture2D* TextureCube_CreateStorageView(TextureCube* This, int32_t face, int32_t mipLevel) {
  assert(!"unimplemented");
  return nullptr;
}

uint32_t TextureCube_MinBufferWidth(TextureCube* This) { return This->MinBufferWidth(); }

void TextureCube_CopyFromBuffer(TextureCube*    dest,
                                CommandEncoder* encoder,
                                Buffer*         source,
                                uint32_t        width,
                                uint32_t        height,
                                uint32_t        faces,
                                uint32_t*       origin) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, height, faces},
                       {origin[0], origin[1], origin[2]});
}

Sampler* Sampler_Sampler(Device*     device,
                         AddressMode addressModeU,
                         AddressMode addressModeV,
                         AddressMode addressModeW,
                         FilterMode  magFilter,
                         FilterMode  minFilter,
                         FilterMode  mipmapFilter) {
  wgpu::SamplerDescriptor desc;
  desc.addressModeU = ToDawnAddressMode(addressModeU);
  desc.addressModeV = ToDawnAddressMode(addressModeV);
  desc.addressModeW = ToDawnAddressMode(addressModeW);
  desc.magFilter = ToDawnFilterMode(magFilter);
  desc.minFilter = ToDawnFilterMode(minFilter);
  desc.mipmapFilter = ToDawnMipmapFilterMode(mipmapFilter);
  wgpu::Sampler sampler = device->device.CreateSampler(&desc);
  return new Sampler(sampler);
}

void Sampler_Destroy(Sampler* This) { delete This; }

void CommandEncoder_CopyBufferToBuffer(CommandEncoder* encoder, Buffer* source, Buffer* dest) {
  encoder->encoder.CopyBufferToBuffer(source->buffer, 0, dest->buffer, 0, source->sizeInBytes);
}

#if TARGET_IS_WASM
EM_ASYNC_JS(WGPUBufferMapAsyncStatus,
            JSMapSync,
            (WGPUBuffer bufferID, WGPUMapMode mode, int offset, int size),
            {
              const bufferWrapper = WebGPU.mgrBuffer.objects[bufferID];
              const buffer = bufferWrapper.object;

              const result = await buffer.mapAsync(mode, offset, size);
              bufferWrapper.mapMode = mode;
              bufferWrapper.onUnmap = [];
              return result;
            });
#endif

static Object* MapSync(wgpu::MapMode mapMode, Buffer* buffer) {
  WGPUBufferMapAsyncStatus status = WGPUBufferMapAsyncStatus_Unknown;
  if (buffer->mappedObject.ptr != nullptr) { return &buffer->mappedObject; }
  auto callback = [](WGPUBufferMapAsyncStatus status, void* userData) {
    *(WGPUBufferMapAsyncStatus*)userData = status;
  };
#if TARGET_IS_WASM
  status =
      JSMapSync(buffer->buffer.Get(), static_cast<WGPUMapMode>(mapMode), 0, buffer->sizeInBytes);
#else
  buffer->buffer.MapAsync(mapMode, 0, buffer->sizeInBytes, callback, &status);
  while (status == WGPUBufferMapAsyncStatus_Unknown) {
    buffer->device.Tick();
  }
#endif
  Object result;
  if (status != WGPUBufferMapAsyncStatus_Success) { return &buffer->mappedObject; }
  if (!(mapMode & wgpu::MapMode::Write)) {
    const void* ptr = buffer->buffer.GetConstMappedRange();
    buffer->mappedObject.ptr = const_cast<void*>(ptr);
  } else {
    buffer->mappedObject.ptr = buffer->buffer.GetMappedRange();
  }
#if TARGET_IS_X86
  ControlBlock* controlBlock =
      static_cast<ControlBlock*>(_aligned_malloc(sizeof(ControlBlock), 16));
#else
  ControlBlock* controlBlock = static_cast<ControlBlock*>(malloc(sizeof(ControlBlock)));
#endif
  controlBlock->strongRefs = controlBlock->weakRefs = 1;
  controlBlock->type = buffer->type;
  controlBlock->arrayLength = buffer->length;
  controlBlock->type = buffer->type;
  buffer->mappedObject.controlBlock = controlBlock;
  return &buffer->mappedObject;
}

Buffer* Buffer_Buffer(int qualifiers, Type* type, Device* device, uint32_t dynamicArraySize) {
  wgpu::BufferDescriptor desc;
  desc.usage = toDawnBufferUsage(qualifiers);
  desc.size = type->GetSizeInBytes(dynamicArraySize);
  wgpu::Buffer b = device->device.CreateBuffer(&desc);
  return new Buffer(device->device, b, dynamicArraySize, desc.size, type);
}

Object* Buffer_MapRead(Buffer* buffer) { return MapSync(wgpu::MapMode::Read, buffer); }

Object* Buffer_MapWrite(Buffer* buffer) { return MapSync(wgpu::MapMode::Write, buffer); }

Object* Buffer_MapReadWrite(Buffer* buffer) {
  return MapSync(wgpu::MapMode::Read | wgpu::MapMode::Write, buffer);
}

void Buffer_Unmap(Buffer* buffer) {
  buffer->buffer.Unmap();
  ControlBlock* controlBlock = buffer->mappedObject.controlBlock;
  controlBlock->strongRefs = 0;
  if (controlBlock->weakRefs == 0) {
#if TARGET_IS_X86
    _aligned_free(controlBlock);
#else
    free(controlBlock);
#endif
  }
  buffer->mappedObject.ptr = nullptr;
  buffer->mappedObject.controlBlock = nullptr;
}

void Buffer_SetData(Buffer* buffer, Object* object) {
  Type* type = object->controlBlock->type;
  assert(!type->IsPtr());
  size_t      size = type->GetSizeInBytes(object->controlBlock->arrayLength);
  wgpu::Queue queue = buffer->device.GetQueue();
  queue.WriteBuffer(buffer->buffer, 0, object->ptr, size);
}

void Buffer_Destroy(Buffer* This) { delete This; }

CommandEncoder* CommandEncoder_CommandEncoder(Device* device) {
  wgpu::CommandEncoderDescriptor desc;
  return new CommandEncoder(device->device.CreateCommandEncoder(&desc));
}

void CommandEncoder_Destroy(CommandEncoder* This) { delete This; }

void Queue_Submit(Queue* queue, CommandBuffer* commandBuffer) {
  queue->queue.Submit(1, &commandBuffer->commandBuffer);
}

void RenderPassEncoder_SetBindGroup(RenderPassEncoder* encoder,
                                    uint32_t           groupIndex,
                                    BindGroup*         bindGroup) {
  encoder->encoder.SetBindGroup(groupIndex, bindGroup->bindGroup, 0, 0);
}

void RenderPassEncoder_SetPipeline(RenderPassEncoder* encoder, RenderPipeline* pipeline) {
  encoder->encoder.SetPipeline(pipeline->pipeline);
}

void RenderPassEncoder_SetVertexBuffer(RenderPassEncoder* encoder, uint32_t slot, Buffer* buffer) {
  encoder->encoder.SetVertexBuffer(slot, buffer->buffer, 0, buffer->sizeInBytes);
}

void RenderPassEncoder_SetIndexBuffer(RenderPassEncoder* encoder, Buffer* buffer) {
  // FIXME: add support for Uint16
  encoder->encoder.SetIndexBuffer(buffer->buffer, wgpu::IndexFormat::Uint32, 0,
                                  buffer->sizeInBytes);
}

void RenderPassEncoder_Draw(RenderPassEncoder* encoder,
                            uint32_t           vertexCount,
                            uint32_t           instanceCount,
                            uint32_t           firstVertex,
                            uint32_t           firstInstance) {
  encoder->encoder.Draw(vertexCount, instanceCount, firstVertex, firstInstance);
}

void RenderPassEncoder_DrawIndexed(RenderPassEncoder* encoder,
                                   uint32_t           indexCount,
                                   uint32_t           instanceCount,
                                   uint32_t           firstVertex,
                                   uint32_t           baseVertex,
                                   uint32_t           firstInstance) {
  encoder->encoder.DrawIndexed(indexCount, instanceCount, firstVertex, baseVertex, firstInstance);
}

void RenderPassEncoder_End(RenderPassEncoder* encoder) { encoder->encoder.End(); }

void RenderPassEncoder_Destroy(RenderPassEncoder* This) { delete This; }

void ComputePassEncoder_SetBindGroup(ComputePassEncoder* encoder,
                                     uint32_t            groupIndex,
                                     BindGroup*          bindGroup) {
  encoder->encoder.SetBindGroup(groupIndex, bindGroup->bindGroup, 0, 0);
}

void ComputePassEncoder_SetPipeline(ComputePassEncoder* encoder, ComputePipeline* pipeline) {
  encoder->encoder.SetPipeline(pipeline->pipeline);
}

void ComputePassEncoder_Dispatch(ComputePassEncoder* encoder,
                                 uint32_t            workgroupCountX,
                                 uint32_t            workgroupCountY,
                                 uint32_t            workgroupCountZ) {
  encoder->encoder.DispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
}

void ComputePassEncoder_End(ComputePassEncoder* encoder) { encoder->encoder.End(); }

void ComputePassEncoder_Destroy(ComputePassEncoder* This) { delete This; }

RenderPassEncoder* CommandEncoder_BeginRenderPass(CommandEncoder* encoder,
                                                  Texture2D*      colorAttachment,
                                                  Texture2D*      depthAttachment,
                                                  float           r,
                                                  float           g,
                                                  float           b,
                                                  float           a) {
  wgpu::RenderPassColorAttachment rpColorAttachment;
  rpColorAttachment.view = CreateRenderable2DView(colorAttachment);
  rpColorAttachment.clearValue = {r, g, b, a};
  rpColorAttachment.loadOp = wgpu::LoadOp::Clear;
  rpColorAttachment.storeOp = wgpu::StoreOp::Store;
  wgpu::RenderPassColorAttachment*       colorAttachments = {&rpColorAttachment};
  wgpu::RenderPassDepthStencilAttachment depthStencilAttachment;
  wgpu::RenderPassDescriptor             desc;
  desc.colorAttachmentCount = 1;
  desc.colorAttachments = colorAttachments;
  if (depthAttachment) {
    depthStencilAttachment.view = CreateRenderable2DView(depthAttachment);
    depthStencilAttachment.depthLoadOp = wgpu::LoadOp::Clear;
    depthStencilAttachment.depthStoreOp = wgpu::StoreOp::Store;
    depthStencilAttachment.depthClearValue = 1.0f;
    desc.depthStencilAttachment = &depthStencilAttachment;
  }
  return new RenderPassEncoder(encoder->encoder.BeginRenderPass(&desc));
}

ComputePassEncoder* CommandEncoder_BeginComputePass(CommandEncoder* encoder) {
  wgpu::ComputePassDescriptor desc;
  return new ComputePassEncoder(encoder->encoder.BeginComputePass(&desc));
}

CommandBuffer* CommandEncoder_Finish(CommandEncoder* encoder) {
  return new CommandBuffer(encoder->encoder.Finish());
}

void CommandBuffer_Destroy(CommandBuffer* This) { delete This; }

Texture2D* SwapChain_GetCurrentTexture(SwapChain* swapChain) {
  return new Texture2D(swapChain->swapChain.GetCurrentTexture(), swapChain->extent, swapChain->format);
}

#if !TARGET_IS_MAC
#if !TARGET_IS_WASM
void SwapChain_Present(SwapChain* swapChain) { swapChain->swapChain.Present(); }
#endif

void SwapChain_Destroy(SwapChain* This) { delete This; }
#endif

float Math_sqrt(float f) { return sqrtf(f); }

float Math_rand() { return (float)(rand() % 100) / 100.0f; }

float Math_sin(float f) { return static_cast<float>(sin(f)); }

float Math_cos(float f) { return static_cast<float>(cos(f)); }

float Math_abs(float f) { return abs(f); }

void Math_Destroy(Math* This) {}

void System_Destroy(System* This) {}

void Event_Destroy(Event* This) { delete This; }

};  // namespace Toucan
