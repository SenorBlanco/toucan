// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#if !TARGET_OS_IS_WASM
#include <dawn/dawn_proc.h>
#include <dawn/native/DawnNative.h>
#endif

#include <assert.h>
#include <stdio.h>

#include <cstring>
#include <unordered_map>

#if TARGET_OS_IS_WASM
#include <emscripten.h>
#endif

#include <webgpu/webgpu_cpp.h>

#include <ast/native_class.h>
#include <ast/type.h>
#include "api_internal.h"

namespace Toucan {

bool exitOnAbort;

namespace {

wgpu::Instance gInstance;
std::unordered_map<void*, wgpu::Buffer> gMappedBuffers;

uint32_t BytesPerPixel(wgpu::TextureFormat format) {
  switch (format) {
    case wgpu::TextureFormat::RGBA8Unorm:
    case wgpu::TextureFormat::RGBA8Snorm:
    case wgpu::TextureFormat::RGBA8Uint:
    case wgpu::TextureFormat::RGBA8Sint:
    case wgpu::TextureFormat::BGRA8Unorm: return 4;
    default: assert(!"unknown Format"); return 0;
  }
}

wgpu::TextureUsage ToDawnTextureUsage(int qualifiers) {
  wgpu::TextureUsage result = wgpu::TextureUsage::CopySrc | wgpu::TextureUsage::CopyDst;

  if (qualifiers & Type::Qualifier::Storage) { result |= wgpu::TextureUsage::StorageBinding; }
  if (qualifiers & Type::Qualifier::Sampleable) { result |= wgpu::TextureUsage::TextureBinding; }
  if (qualifiers & Type::Qualifier::Renderable) { result |= wgpu::TextureUsage::RenderAttachment; }
  return result;
}

wgpu::LoadOp ToDawnLoadOp(LoadOp loadOp) {
  switch (loadOp) {
    case LoadOp::Undefined: return wgpu::LoadOp::Undefined;
    case LoadOp::Load: return wgpu::LoadOp::Load;
    case LoadOp::Clear: return wgpu::LoadOp::Clear;
    default: assert(!"unknown LoadOp"); return wgpu::LoadOp::Load;
  }
}

wgpu::StoreOp ToDawnStoreOp(StoreOp loadOp) {
  switch (loadOp) {
    case StoreOp::Undefined: return wgpu::StoreOp::Undefined;
    case StoreOp::Store: return wgpu::StoreOp::Store;
    case StoreOp::Discard: return wgpu::StoreOp::Discard;
    default: assert(!"unknown StoreOp"); return wgpu::StoreOp::Store;
  }
}

void UnmapBuffer(void* This) {
  gMappedBuffers[This].Unmap();
  gMappedBuffers[This] = nullptr;
}

}  // namespace

struct TextureView {
  TextureView(wgpu::TextureView v) : view(v) {}
  wgpu::TextureView view;
};

struct SampleableTexture1D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture2DArray : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTexture3D : public TextureView {
  using TextureView::TextureView;
};
struct SampleableTextureCube : public TextureView {
  using TextureView::TextureView;
};

struct Texture {
  Texture(wgpu::Texture t, wgpu::TextureView v) : texture(t), view(v) {}
  Texture(int                    qualifiers,
          Type*                  pixelFormat,
          wgpu::Device           device,
          wgpu::TextureDimension dimension,
          wgpu::Extent3D         size,
          uint32_t               mipLevelCount) {
    wgpu::TextureDescriptor desc;
    desc.usage = ToDawnTextureUsage(qualifiers);
    desc.size = size;
    desc.mipLevelCount = mipLevelCount;
    desc.format = ToDawnTextureFormat(pixelFormat);
    desc.dimension = dimension;
    texture = device.CreateTexture(&desc);
    view = texture.CreateView();
  }
  Texture(Texture* t, wgpu::TextureView view) : Texture(t->texture, view) {}
  uint32_t MinBufferWidth() {
    uint32_t bytesPerPixel = BytesPerPixel(texture.GetFormat());
    return (((texture.GetWidth() * bytesPerPixel + 255) >> 8) << 8) / bytesPerPixel;
  }

  void CopyFromBuffer(wgpu::CommandEncoder encoder,
                      wgpu::Buffer         source,
                      wgpu::Extent3D       extent,
                      wgpu::Origin3D       origin,
                      uint32_t             mipLevel) {
    wgpu::TexelCopyBufferInfo sourceInfo;
    sourceInfo.buffer = source;
    sourceInfo.layout.bytesPerRow = MinBufferWidth() * BytesPerPixel(texture.GetFormat());
    sourceInfo.layout.rowsPerImage = texture.GetHeight();
    wgpu::TexelCopyTextureInfo destInfo;
    destInfo.texture = texture;
    destInfo.origin = origin;
    destInfo.mipLevel = mipLevel;
    encoder.CopyBufferToTexture(&sourceInfo, &destInfo, &extent);
  }
  virtual wgpu::TextureViewDimension GetViewDimension() const = 0;
  wgpu::TextureView CreateView(
      uint32_t                   baseMipLevel = 0,
      uint32_t                   mipLevelCount = 0,
      uint32_t                   baseArrayLayer = 0,
      uint32_t                   arrayLayerCount = 0,
      wgpu::TextureViewDimension dimension = wgpu::TextureViewDimension::Undefined) {
    if (mipLevelCount == 0) mipLevelCount = wgpu::kMipLevelCountUndefined;
    if (arrayLayerCount == 0) arrayLayerCount = wgpu::kArrayLayerCountUndefined;
    if (dimension == wgpu::TextureViewDimension::Undefined) dimension = GetViewDimension();
    wgpu::TextureViewDescriptor desc;
    desc.format = texture.GetFormat();
    desc.dimension = dimension;
    desc.baseMipLevel = baseMipLevel;
    desc.mipLevelCount = mipLevelCount;
    desc.baseArrayLayer = baseArrayLayer;
    desc.arrayLayerCount = arrayLayerCount;
    return texture.CreateView(&desc);
  }
  wgpu::TextureView Create2DView(uint32_t                   baseMipLevel = 0,
                                 uint32_t                   baseArrayLayer = 0) {
    return CreateView(baseMipLevel, 1, baseArrayLayer, 1, wgpu::TextureViewDimension::e2D);
  }
  wgpu::Texture       texture;
  wgpu::TextureView   view;
};

struct Texture1D : public Texture {
  using Texture::Texture;
  wgpu::TextureViewDimension GetViewDimension() const override {
    return wgpu::TextureViewDimension::e1D;
  }
};
struct Texture2D : public Texture {
  using Texture::Texture;
  wgpu::TextureViewDimension GetViewDimension() const override {
    return wgpu::TextureViewDimension::e2D;
  }
};
struct Texture2DArray : public Texture {
  using Texture::Texture;
  wgpu::TextureViewDimension GetViewDimension() const override {
    return wgpu::TextureViewDimension::e2DArray;
  }
};
struct Texture3D : public Texture {
  using Texture::Texture;
  wgpu::TextureViewDimension GetViewDimension() const override {
    return wgpu::TextureViewDimension::e3D;
  }
};
struct TextureCube : public Texture {
  using Texture::Texture;
  wgpu::TextureViewDimension GetViewDimension() const override {
    return wgpu::TextureViewDimension::Cube;
  }
};

struct Sampler {
  Sampler(wgpu::Sampler s) : sampler(s) {}
  wgpu::Sampler sampler;
};

struct Buffer {
  Buffer(wgpu::Device d, wgpu::Buffer b, int l, int s, Type* t)
      : device(d), buffer(b), length(l), sizeInBytes(s), type(t) {}
  wgpu::Device device;
  wgpu::Buffer buffer;
  int          length;
  int          sizeInBytes;
  Type*        type;
  Object       mappedObject = {nullptr, nullptr};
};

struct RenderPipeline {
  RenderPipeline(wgpu::RenderPipeline p) : pipeline(p) {}
  wgpu::RenderPipeline pipeline;
};

struct ComputePipeline {
  ComputePipeline(wgpu::ComputePipeline p) : pipeline(p) {}
  wgpu::ComputePipeline pipeline;
};

wgpu::TextureFormat ToDawnTextureFormat(Type* format) {
  assert(format->IsClass());
  auto classType = static_cast<ClassType*>(format);
  if (classType->GetName() == "RGBA8unorm") {
    return wgpu::TextureFormat::RGBA8Unorm;
  } else if (classType->GetName() == "BGRA8unorm") {
    return wgpu::TextureFormat::BGRA8Unorm;
  } else if (classType->GetName() == "RGBA8snorm") {
    return wgpu::TextureFormat::RGBA8Snorm;
  } else if (classType->GetName() == "Depth24Plus") {
    return wgpu::TextureFormat::Depth24Plus;
  } else if (classType->GetName() == "PreferredPixelFormat") {
    return GetPreferredPixelFormat();
  } else if (classType->GetName() == "RGBA16float") {
    return wgpu::TextureFormat::RGBA16Float;
  } else if (classType->GetName() == "RG16float") {
    return wgpu::TextureFormat::RG16Float;
  } else if (classType->GetName() == "R16float") {
    return wgpu::TextureFormat::R16Float;
  } else {
    assert(!"unknown Format");
    return wgpu::TextureFormat::RGBA8Unorm;
  }
}

wgpu::TextureSampleType ToDawnTextureSampleType(ClassType* type, int qualifiers) {
  Type* arg = type->GetTemplateArgs()[0];
  if (arg->IsFloat()) {
    if (qualifiers & Type::Qualifier::Unfilterable) {
      return wgpu::TextureSampleType::UnfilterableFloat;
    } else {
      return wgpu::TextureSampleType::Float;
    }
  } else if (arg->IsInt()) {
    return wgpu::TextureSampleType::Sint;
  } else if (arg->IsUInt()) {
    return wgpu::TextureSampleType::Uint;
  } else {
    assert(!"unknown texture sample type");
    return wgpu::TextureSampleType::Float;
  }
}

static wgpu::VertexFormat toDawnVertexFormat(Type* type) {
  if (type->IsVector()) {
    VectorType* v = static_cast<VectorType*>(type);
    if (v->GetElementType()->IsInt()) {
      switch (v->GetNumElements()) {
        case 2: return wgpu::VertexFormat::Sint32x2;
        case 3: return wgpu::VertexFormat::Sint32x3;
        case 4: return wgpu::VertexFormat::Sint32x4;
      }
    } else if (v->GetElementType()->IsFloat()) {
      switch (v->GetNumElements()) {
        case 2: return wgpu::VertexFormat::Float32x2;
        case 3: return wgpu::VertexFormat::Float32x3;
        case 4: return wgpu::VertexFormat::Float32x4;
      }
    } else if (v->GetElementType()->IsUInt()) {
      switch (v->GetNumElements()) {
        case 2: return wgpu::VertexFormat::Uint32x2;
        case 3: return wgpu::VertexFormat::Uint32x3;
        case 4: return wgpu::VertexFormat::Uint32x4;
      }
    }
  } else if (type->IsInt()) {
    return wgpu::VertexFormat::Sint32;
  } else if (type->IsFloat()) {
    return wgpu::VertexFormat::Float32;
  } else if (type->IsUInt()) {
    return wgpu::VertexFormat::Uint32;
  }
  assert(!"invalid vertex format");
  return wgpu::VertexFormat::Uint8x2;
}

static wgpu::IndexFormat toDawnIndexFormat(Type* type) {
  if (type->IsUInt()) {
    return wgpu::IndexFormat::Uint32;
  } else if (type->IsUShort()) {
    return wgpu::IndexFormat::Uint16;
  }
  assert(!"invalid index format");
  return wgpu::IndexFormat::Undefined;
}

static wgpu::AddressMode ToDawnAddressMode(AddressMode mode) {
  switch (mode) {
    case AddressMode::Repeat: return wgpu::AddressMode::Repeat;
    case AddressMode::MirrorRepeat: return wgpu::AddressMode::MirrorRepeat;
    case AddressMode::ClampToEdge: return wgpu::AddressMode::ClampToEdge;
  }
  assert(!"unknown address mode");
  return wgpu::AddressMode::Repeat;
}

static wgpu::FilterMode ToDawnFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::FilterMode::Nearest;
    case FilterMode::Linear: return wgpu::FilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::FilterMode::Nearest;
}

static wgpu::MipmapFilterMode ToDawnMipmapFilterMode(FilterMode mode) {
  switch (mode) {
    case FilterMode::Nearest: return wgpu::MipmapFilterMode::Nearest;
    case FilterMode::Linear: return wgpu::MipmapFilterMode::Linear;
  }
  assert(!"unknown filter mode");
  return wgpu::MipmapFilterMode::Nearest;
}

static wgpu::BlendFactor toDawnBlendFactor(BlendFactor factor) {
  switch (factor) {
    case BlendFactor::Zero:                 return wgpu::BlendFactor::Zero;
    case BlendFactor::One:                  return wgpu::BlendFactor::One;
    case BlendFactor::Src:                  return wgpu::BlendFactor::Src;
    case BlendFactor::OneMinusSrc:          return wgpu::BlendFactor::OneMinusSrc;
    case BlendFactor::SrcAlpha:             return wgpu::BlendFactor::SrcAlpha;
    case BlendFactor::OneMinusSrcAlpha:     return wgpu::BlendFactor::OneMinusSrcAlpha;
    case BlendFactor::Dst:                  return wgpu::BlendFactor::Dst;
    case BlendFactor::OneMinusDst:          return wgpu::BlendFactor::OneMinusDst;
    case BlendFactor::DstAlpha:             return wgpu::BlendFactor::DstAlpha;
    case BlendFactor::OneMinusDstAlpha:     return wgpu::BlendFactor::OneMinusDstAlpha;
    case BlendFactor::SrcAlphaSaturated:    return wgpu::BlendFactor::SrcAlphaSaturated;
    case BlendFactor::Constant:             return wgpu::BlendFactor::Constant;
    case BlendFactor::OneMinusConstant:     return wgpu::BlendFactor::OneMinusConstant;
    default:                                return wgpu::BlendFactor::One;
  }
}

static wgpu::BlendOperation toDawnBlendOperation(BlendOp op) {
  switch (op) {
    case BlendOp::Add:               return wgpu::BlendOperation::Add;
    case BlendOp::Subtract:          return wgpu::BlendOperation::Subtract;
    case BlendOp::ReverseSubtract:   return wgpu::BlendOperation::ReverseSubtract;
    case BlendOp::Min:               return wgpu::BlendOperation::Min;
    case BlendOp::Max:               return wgpu::BlendOperation::Max;
    default:                         return wgpu::BlendOperation::Add;
  }
}


static wgpu::BlendComponent toDawnBlendComponent(BlendComponent component) {
  return wgpu::BlendComponent{ toDawnBlendOperation(component.operation),
                               toDawnBlendFactor(component.srcFactor),
                               toDawnBlendFactor(component.dstFactor) };
}

static wgpu::BlendState toDawnBlendState(BlendState state) {
  return wgpu::BlendState{ toDawnBlendComponent(state.color), toDawnBlendComponent(state.alpha)};
}

// FIXME: this should handle a mask, properly
static wgpu::BufferUsage toDawnBufferUsage(int qualifiers) {
  wgpu::BufferUsage result = wgpu::BufferUsage::None;
  bool              gpu = false;
  if (qualifiers & Type::Qualifier::Index) {
    result |= wgpu::BufferUsage::Index;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Vertex) {
    result |= wgpu::BufferUsage::Vertex;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Uniform) {
    result |= wgpu::BufferUsage::Uniform;
    gpu = true;
  }
  if (qualifiers & Type::Qualifier::Storage) {
    result |= wgpu::BufferUsage::Storage;
    gpu = true;
  }
  if (gpu) {
    result |= wgpu::BufferUsage::CopySrc | wgpu::BufferUsage::CopyDst;
  } else {
    if (qualifiers & (Type::Qualifier::HostReadable)) {
      result |= wgpu::BufferUsage::MapRead | wgpu::BufferUsage::CopyDst;
    }
    if (qualifiers & (Type::Qualifier::HostWriteable)) {
      result |= wgpu::BufferUsage::MapWrite | wgpu::BufferUsage::CopySrc;
    }
  }
  return result;
}

static wgpu::PrimitiveTopology toDawnPrimitiveTopology(PrimitiveTopology type) {
  switch (type) {
    case PrimitiveTopology::PointList: return wgpu::PrimitiveTopology::PointList;
    case PrimitiveTopology::LineList: return wgpu::PrimitiveTopology::LineList;
    case PrimitiveTopology::LineStrip: return wgpu::PrimitiveTopology::LineStrip;
    case PrimitiveTopology::TriangleList: return wgpu::PrimitiveTopology::TriangleList;
    case PrimitiveTopology::TriangleStrip: return wgpu::PrimitiveTopology::TriangleStrip;
    default: assert(!"unknown PrimitiveTopology"); return wgpu::PrimitiveTopology::PointList;
  }
}

static wgpu::CullMode toDawnCullMode(CullMode cullMode) {
  switch (cullMode) {
    case CullMode::None:  return wgpu::CullMode::None;
    case CullMode::Front: return wgpu::CullMode::Front;
    case CullMode::Back:  return wgpu::CullMode::Back;
    default: assert(!"unknown CullMode"); return wgpu::CullMode::None;
  }
}

static wgpu::FrontFace toDawnFrontFace(FrontFace frontFace) {
  switch (frontFace) {
    case FrontFace::CCW:   return wgpu::FrontFace::CCW;
    case FrontFace::CW:    return wgpu::FrontFace::CW;
    default: assert(!"unknown FrontFace"); return wgpu::FrontFace::CCW;
  }
}

wgpu::VertexBufferLayout toDawnVertexBufferLayout(Type*                               vertexInput,
                                                  std::vector<wgpu::VertexAttribute>* vaDescs) {
  size_t start = vaDescs->size();
  if (vertexInput->IsClass()) {
    auto               classType = static_cast<ClassType*>(vertexInput);
    const FieldVector& fields = classType->GetFields();
    for (int i = 0; i < fields.size(); i++) {
      wgpu::VertexAttribute vaDesc;
      vaDesc.shaderLocation = vaDescs->size();
      vaDesc.offset = fields[i]->offset;
      vaDesc.format = toDawnVertexFormat(fields[i]->type);
      vaDescs->push_back(vaDesc);
    }
  } else {
    wgpu::VertexAttribute vaDesc;
    vaDesc.shaderLocation = vaDescs->size();
    vaDesc.offset = 0;
    vaDesc.format = toDawnVertexFormat(vertexInput);
    vaDescs->push_back(vaDesc);
  }
  wgpu::VertexBufferLayout input;
  input.arrayStride = vertexInput->GetSizeInBytes();
  input.stepMode = wgpu::VertexStepMode::Vertex;
  input.attributeCount = vaDescs->size() - start;
  // Cast the start offset to pointer; this will be added to the vaDesc pointer
  // in FinalizeVertexLayouts. This is necessary to accommodate reallocation
  // of the vertex attribute vector.
  input.attributes = reinterpret_cast<wgpu::VertexAttribute*>(start);
  return input;
}

wgpu::BufferBindingType toDawnBufferBindingType(int qualifiers) {
  if (qualifiers & Type::Qualifier::Uniform) { return wgpu::BufferBindingType::Uniform; }
  if (qualifiers & Type::Qualifier::Storage) {
    if (qualifiers & Type::Qualifier::ReadOnly) {
      return wgpu::BufferBindingType::ReadOnlyStorage;
    } else {
      return wgpu::BufferBindingType::Storage;
    }
  }
  assert(!"invalid qualifiers for buffer binding");
#if TARGET_OS_IS_WASM
  return wgpu::BufferBindingType::Undefined;
#else
  return wgpu::BufferBindingType::BindingNotUsed;
#endif
}

// FIXME: store this in Device.
std::unordered_map<Type*, wgpu::BindGroupLayout> bindGroupLayoutCache;

static wgpu::BindGroupLayoutEntry CreateBindGroupLayoutEntry(uint32_t binding,
                                                             Type*    type,
                                                             int      qualifiers) {
  assert(!type->IsPtr());
  assert(type->IsClass());
  ClassType*                 classType = static_cast<ClassType*>(type);
  wgpu::BindGroupLayoutEntry entry;
  // FIXME: get visibilty from qualifiers
  entry.binding = binding;
  if (qualifiers & Type::Qualifier::Storage) {
    entry.visibility = wgpu::ShaderStage::Compute | wgpu::ShaderStage::Fragment;
  } else {
    entry.visibility =
        wgpu::ShaderStage::Vertex | wgpu::ShaderStage::Fragment | wgpu::ShaderStage::Compute;
  }
  if (classType == NativeClass::Sampler) {
    entry.sampler.type = wgpu::SamplerBindingType::Filtering;
    return entry;
  }
  ClassType* templ = classType->GetTemplate();
  assert(templ);
  if (templ == NativeClass::Buffer) {
    entry.buffer.type = toDawnBufferBindingType(qualifiers);
  } else if (templ == NativeClass::SampleableTexture1D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType, qualifiers);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e1D;
  } else if (templ == NativeClass::SampleableTexture2D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType, qualifiers);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2D;
  } else if (templ == NativeClass::SampleableTexture3D) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType, qualifiers);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e3D;
  } else if (templ == NativeClass::SampleableTexture2DArray) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType, qualifiers);
    entry.texture.viewDimension = wgpu::TextureViewDimension::e2DArray;
  } else if (templ == NativeClass::SampleableTextureCube) {
    entry.texture.sampleType = ToDawnTextureSampleType(classType, qualifiers);
    entry.texture.viewDimension = wgpu::TextureViewDimension::Cube;
  } else {
    assert(!"invalid field type in bind group");
  }
  return entry;
}

static void CreateBindGroupLayoutEntries(ClassType*                               classType,
                                         int                                      qualifiers,
                                         std::vector<wgpu::BindGroupLayoutEntry>* entries) {
  if (classType->GetParent()) {
    CreateBindGroupLayoutEntries(classType->GetParent(), qualifiers, entries);
  }
  uint32_t bindingIndex = 0;
  for (const auto& field : classType->GetFields()) {
    assert(field->type->IsPtr());
    Type* type = static_cast<PtrType*>(field->type)->GetBaseType();
    type = type->GetUnqualifiedType(&qualifiers);
    auto entry = CreateBindGroupLayoutEntry(bindingIndex, type, qualifiers);
    bindingIndex++;
    entries->push_back(entry);
  }
}

static wgpu::BindGroupLayout GetOrCreateBindGroupLayout(Device* device, Type* type) {
  assert(!type->IsPtr());
  if (auto layout = bindGroupLayoutCache[type]) { return layout; }
  int qualifiers;
  type = type->GetUnqualifiedType(&qualifiers);
  std::vector<wgpu::BindGroupLayoutEntry> entries;
  assert(type->IsClass());
  CreateBindGroupLayoutEntries(static_cast<ClassType*>(type), qualifiers, &entries);
  wgpu::BindGroupLayoutDescriptor desc;
  desc.entryCount = entries.size();
  desc.entries = entries.data();
  auto layout = device->device.CreateBindGroupLayout(&desc);
  bindGroupLayoutCache[type] = layout;
  return layout;
}

wgpu::BindGroupEntry CreateBindGroupEntry(Type* type, int binding, void* data) {
  wgpu::BindGroupEntry entry;
  entry.binding = binding;
  entry.buffer = nullptr;
  entry.sampler = nullptr;
  entry.textureView = nullptr;
  if (type->IsPtr()) { type = static_cast<PtrType*>(type)->GetBaseType(); }
  int qualifiers = 0;
  type = type->GetUnqualifiedType(&qualifiers);
  assert(type->IsClass() && "bind group entry must be of class type");
  ClassType* c = static_cast<ClassType*>(type);
  if (c == NativeClass::Sampler) {
    Sampler* sampler = static_cast<Sampler*>(data);
    entry.sampler = sampler->sampler;
    return entry;
  }
  ClassType* templ = c->GetTemplate();
  assert(templ);
  if (templ == NativeClass::SampleableTexture1D || templ == NativeClass::SampleableTexture2D ||
      templ == NativeClass::SampleableTexture3D || templ == NativeClass::SampleableTexture2DArray ||
      templ == NativeClass::SampleableTextureCube) {
    TextureView* textureView = static_cast<TextureView*>(data);
    entry.textureView = textureView->view;
  } else if (templ == NativeClass::Buffer) {
    Buffer* buffer = static_cast<Buffer*>(data);
    entry.buffer = buffer->buffer;
    entry.size = buffer->sizeInBytes;
  } else {
    assert("!unknown BindGroup entry type");
  }
  return entry;
}

struct BindGroup {
  BindGroup(wgpu::BindGroup b) : bindGroup(b) {}
  wgpu::BindGroup bindGroup;
};

struct BindGroupLayout {
  BindGroupLayout(wgpu::BindGroupLayout b) : bindGroupLayout(b) {}
  wgpu::BindGroupLayout bindGroupLayout;
};

struct VertexInput {
  VertexInput(const wgpu::Buffer& b) : buffer(b) {}
  wgpu::Buffer buffer;
};

struct ColorOutput {
  ColorOutput(const wgpu::RenderPassColorAttachment& a) : attachment(a) {}
  wgpu::RenderPassColorAttachment attachment;
};

struct DepthStencilOutput {
  DepthStencilOutput(const wgpu::RenderPassDepthStencilAttachment& a) : attachment(a) {}
  wgpu::RenderPassDepthStencilAttachment attachment;
};

struct RenderPass {
  RenderPass(wgpu::RenderPassEncoder e, Type* t) : encoder(e), type(t) {}
  wgpu::RenderPassEncoder encoder;
  Type*                   type;
};

struct ComputePass {
  ComputePass(wgpu::ComputePassEncoder e, Type* t) : encoder(e), type(t) {}
  wgpu::ComputePassEncoder encoder;
  Type*                    type;
};

struct CommandEncoder {
  CommandEncoder(wgpu::CommandEncoder e) : encoder(e) {}
  wgpu::CommandEncoder encoder;
};

struct CommandBuffer {
  CommandBuffer(wgpu::CommandBuffer cb) : commandBuffer(cb) {}
  wgpu::CommandBuffer commandBuffer;
};

struct Queue {
  Queue(wgpu::Queue q) : queue(q) {}
  wgpu::Queue queue;
};

Queue* Device_GetQueue(Device* device) { return new Queue(device->device.GetQueue()); }

void Device_Destroy(Device* This) { delete This; }

void Queue_Destroy(Queue* This) { delete This; }

wgpu::ShaderModule createShaderModule(Device* device, Method* m) {
  wgpu::ShaderModuleDescriptor desc;
#if TARGET_OS_IS_WASM
  wgpu::ShaderModuleWGSLDescriptor wgslDesc;
  wgslDesc.code = m->wgsl.data();
  desc.nextInChain = &wgslDesc;
#else
  wgpu::ShaderModuleSPIRVDescriptor spirvDesc;
  spirvDesc.codeSize = m->spirv.size();
  spirvDesc.code = m->spirv.data();
  desc.nextInChain = &spirvDesc;
#endif
  return device->device.CreateShaderModule(&desc);
}

struct PipelineLayout {
  std::vector<wgpu::BindGroupLayout>    bindGroupLayouts;
  std::vector<wgpu::ColorTargetState>   colorTargets;
  wgpu::DepthStencilState               depthStencilTarget;
  std::vector<wgpu::VertexAttribute>    vertexAttributes;
  std::vector<wgpu::VertexBufferLayout> vertexBufferLayouts;
  wgpu::IndexFormat                     indexFormat = wgpu::IndexFormat::Undefined;

  void FinalizeVertexLayouts() {
    // Convert each vertexLayout's "attributes" pointers back to an offset,
    // and add it to the vertexAttributes base.
    auto base = vertexAttributes.data();
    for (auto& vertexLayout : vertexBufferLayouts) {
      vertexLayout.attributes = base + reinterpret_cast<size_t>(vertexLayout.attributes);
    }
  }
};

static void ExtractPipelineLayout(ClassType* classType, Device* device, wgpu::BlendState* blendState, PipelineLayout* out) {
  out->depthStencilTarget.format = wgpu::TextureFormat::Undefined;
  if (classType->GetParent()) { ExtractPipelineLayout(classType->GetParent(), device, blendState, out); }
  for (const auto& field : classType->GetFields()) {
    Type* type = field->type;

    assert(type->IsPtr());
    type = static_cast<PtrType*>(type)->GetBaseType();
    int   qualifiers;
    Type* unqualifiedType = type->GetUnqualifiedType(&qualifiers);
    assert(unqualifiedType->IsClass());

    ClassType* classType = static_cast<ClassType*>(unqualifiedType);
    if (classType->GetTemplate() == NativeClass::VertexInput) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      Type* elementType = templateArgs[0];
      auto layout = toDawnVertexBufferLayout(elementType, &out->vertexAttributes);
      out->vertexBufferLayouts.push_back(layout);
    } else if (classType->GetTemplate() == NativeClass::ColorOutput) {
      wgpu::ColorTargetState colorTargetState;
      const auto&            templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      colorTargetState.format = ToDawnTextureFormat(templateArgs[0]);
      colorTargetState.blend = blendState;
      out->colorTargets.push_back(colorTargetState);
    } else if (classType->GetTemplate() == NativeClass::DepthStencilOutput) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      out->depthStencilTarget.format = ToDawnTextureFormat(templateArgs[0]);
    } else if (classType->GetTemplate() == NativeClass::Buffer) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      assert(templateArgs[0]->IsUnsizedArray());
      Type* elementType = static_cast<ArrayType*>(templateArgs[0])->GetElementType();
      if (qualifiers == Type::Qualifier::Index) {
        out->indexFormat = toDawnIndexFormat(elementType);
      }
    } else if (classType->GetTemplate() == NativeClass::BindGroup) {
      const auto& templateArgs = classType->GetTemplateArgs();
      assert(templateArgs.size() == 1);
      wgpu::BindGroupLayout layout = GetOrCreateBindGroupLayout(device, templateArgs[0]);
      out->bindGroupLayouts.push_back(layout);
    } else {
      assert("!invalid type for pipeline variable");
    }
  }
}

struct PipelineData {
  std::vector<wgpu::BindGroup>                 bindGroups;
  std::vector<wgpu::RenderPassColorAttachment> colorAttachments;
  wgpu::RenderPassDepthStencilAttachment       depthStencilAttachment;
  std::vector<wgpu::Buffer>                    vertexBuffers;
  wgpu::Buffer                                 indexBuffer;
  wgpu::IndexFormat                            indexFormat;

  void Set(wgpu::RenderPassEncoder encoder) {
    for (int i = 0; i < bindGroups.size(); i++) {
      if (bindGroups[i]) { encoder.SetBindGroup(i, bindGroups[i]); }
    }
    for (int i = 0; i < vertexBuffers.size(); i++) {
      if (vertexBuffers[i]) { encoder.SetVertexBuffer(i, vertexBuffers[i]); }
    }
    if (indexBuffer) { encoder.SetIndexBuffer(indexBuffer, indexFormat); }
  }

  void Set(wgpu::ComputePassEncoder encoder) {
    for (int i = 0; i < bindGroups.size(); i++) {
      if (bindGroups[i]) { encoder.SetBindGroup(i, bindGroups[i]); }
    }
  }
};

static void ExtractPipelineData(Type* type, void* data, PipelineData* out) {
  assert(type->IsClass());
  auto classType = static_cast<ClassType*>(type);
  if (classType->GetParent()) { ExtractPipelineData(classType->GetParent(), data, out); }
  for (const auto& field : classType->GetFields()) {
    Type* fieldType = field->type;
    assert(fieldType->IsPtr());
    fieldType = static_cast<PtrType*>(fieldType)->GetBaseType();
    int qualifiers;
    fieldType = fieldType->GetUnqualifiedType(&qualifiers);
    Object* object = reinterpret_cast<Object*>((uint8_t*)data + field->offset);
    void* ptr = object->ptr;
    assert(fieldType->IsClass());
    auto classType = static_cast<ClassType*>(fieldType);
    if (classType->GetTemplate() == NativeClass::VertexInput && ptr) {
      out->vertexBuffers.push_back(static_cast<VertexInput*>(ptr)->buffer);
    } else if (classType->GetTemplate() == NativeClass::ColorOutput && ptr) {
      out->colorAttachments.push_back(static_cast<ColorOutput*>(ptr)->attachment);
    } else if (classType->GetTemplate() == NativeClass::DepthStencilOutput && ptr) {
      out->depthStencilAttachment = static_cast<DepthStencilOutput*>(ptr)->attachment;
    } else if (classType->GetTemplate() == NativeClass::Buffer &&
               qualifiers == Type::Qualifier::Index) {
      if (auto buffer = static_cast<Buffer*>(ptr)) {
        out->indexBuffer = buffer ? buffer->buffer : nullptr;
        out->indexFormat =
            toDawnIndexFormat(static_cast<ArrayType*>(buffer->type)->GetElementType());
      }
    } else if (classType->GetTemplate() == NativeClass::BindGroup) {
      out->bindGroups.push_back(ptr ? static_cast<BindGroup*>(ptr)->bindGroup
                                           : nullptr);
    }
  }
}

RenderPipeline* RenderPipeline_RenderPipeline(int               qualifiers,
                                              Type*             type,
                                              Device*           device,
                                              PrimitiveTopology primitiveTopology,
                                              FrontFace         frontFace,
                                              CullMode          cullMode,
                                              DepthStencilState*depthStencil,
                                              BlendState*       blendState) {
  if (!type->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(type);
  wgpu::ShaderModule vertexShader, fragmentShader;
  for (ClassType* c = classType; c != nullptr && (!vertexShader || !fragmentShader);
       c = c->GetParent()) {
    for (auto& method : c->GetMethods()) {
      if (method->modifiers & Method::Modifier::Vertex) {
        if (!vertexShader) {
          vertexShader = createShaderModule(device, method.get());
        }
      } else if (method->modifiers & Method::Modifier::Fragment) {
        if (!fragmentShader) {
          fragmentShader = createShaderModule(device, method.get());
        }
      }
    }
  }
  assert(vertexShader && fragmentShader);
  PipelineLayout pipelineLayout;
  auto dawnBlendState = toDawnBlendState(*blendState);
  ExtractPipelineLayout(classType, device, &dawnBlendState, &pipelineLayout);
  pipelineLayout.FinalizeVertexLayouts();

  wgpu::VertexState vertexState;
  vertexState.module = vertexShader;
  vertexState.entryPoint = "main";
  vertexState.bufferCount = pipelineLayout.vertexBufferLayouts.size();
  vertexState.buffers = pipelineLayout.vertexBufferLayouts.data();
  wgpu::RenderPipelineDescriptor rpDesc;
  wgpu::DepthStencilState        depthStencilState;
  if (pipelineLayout.depthStencilTarget.format != wgpu::TextureFormat::Undefined) {
    depthStencilState.format = pipelineLayout.depthStencilTarget.format;
    depthStencilState.depthWriteEnabled = true;
    depthStencilState.depthCompare = wgpu::CompareFunction::Less;
  }
  wgpu::FragmentState fragmentState;
  fragmentState.module = fragmentShader;
  fragmentState.entryPoint = "main";
  fragmentState.constants = nullptr;
  fragmentState.targetCount = pipelineLayout.colorTargets.size();
  fragmentState.targets = pipelineLayout.colorTargets.data();
  wgpu::PrimitiveState           primitiveState;
  wgpu::PipelineLayoutDescriptor desc;
  desc.bindGroupLayoutCount = pipelineLayout.bindGroupLayouts.size();
  desc.bindGroupLayouts = pipelineLayout.bindGroupLayouts.data();
  rpDesc.layout = device->device.CreatePipelineLayout(&desc);
  rpDesc.vertex = vertexState;
  rpDesc.fragment = &fragmentState;
  rpDesc.primitive.topology = toDawnPrimitiveTopology(primitiveTopology);
  if (primitiveTopology == PrimitiveTopology::LineStrip || primitiveTopology == PrimitiveTopology::TriangleStrip) {
    rpDesc.primitive.stripIndexFormat = pipelineLayout.indexFormat;
  }
  rpDesc.primitive.frontFace = toDawnFrontFace(frontFace);
  rpDesc.primitive.cullMode = toDawnCullMode(cullMode);
  if (pipelineLayout.depthStencilTarget.format != wgpu::TextureFormat::Undefined) {
    rpDesc.depthStencil = &depthStencilState;
  }
  return new RenderPipeline(device->device.CreateRenderPipeline(&rpDesc));
}

void RenderPipeline_Destroy(RenderPipeline* This) { delete This; }

ComputePipeline* ComputePipeline_ComputePipeline(int     qualifiers,
                                                 Type*   computeLayout,
                                                 Device* device) {
  if (!computeLayout->IsClass()) { return nullptr; }
  ClassType*         classType = static_cast<ClassType*>(computeLayout);
  wgpu::ShaderModule computeShader;
  for (auto& method : classType->GetMethods()) {
    if (method->modifiers & Method::Modifier::Compute) {
      if (computeShader) {
        assert(!"more than one compute shader specified");
        return nullptr;
      }
      computeShader = createShaderModule(device, method.get());
    }
  }
  wgpu::ComputeState computeState;
  computeState.module = computeShader;
  computeState.entryPoint = "main";
  wgpu::ComputePipelineDescriptor cpDesc;
  PipelineLayout                  pipelineLayout;
  ExtractPipelineLayout(classType, device, nullptr, &pipelineLayout);
  wgpu::PipelineLayoutDescriptor desc;
  desc.bindGroupLayoutCount = pipelineLayout.bindGroupLayouts.size();
  desc.bindGroupLayouts = pipelineLayout.bindGroupLayouts.data();
  cpDesc.layout = device->device.CreatePipelineLayout(&desc);
  cpDesc.compute = computeState;
  return new ComputePipeline(device->device.CreateComputePipeline(&cpDesc));
}

void ComputePipeline_Destroy(ComputePipeline* This) { delete This; }

BindGroup* BindGroup_BindGroup(int qualifiers, Type* type, Device* device, void* data) {
  assert(type->IsClass() && "bind group argument must be a class type");
  ClassType*                        classType = static_cast<ClassType*>(type);
  wgpu::BindGroupDescriptor         desc;
  std::vector<wgpu::BindGroupEntry> entries;
  desc.entryCount = classType->GetFields().size();
  for (int i = 0; i < desc.entryCount; i++) {
    Field* field = classType->GetFields()[i].get();
    Object* object = reinterpret_cast<Object*>((uint8_t*)data + field->offset);
    entries.push_back(CreateBindGroupEntry(field->type, i, object->ptr));
  }
  desc.entries = entries.data();
  desc.layout = GetOrCreateBindGroupLayout(device, classType);
  return new BindGroup(device->device.CreateBindGroup(&desc));
}

void BindGroup_Destroy(BindGroup* This) { delete This; }

void SampleableTexture1D_Destroy(SampleableTexture1D* This) { delete This; }

void SampleableTexture2D_Destroy(SampleableTexture2D* This) { delete This; }

void SampleableTexture2DArray_Destroy(SampleableTexture2DArray* This) { delete This; }

void SampleableTexture3D_Destroy(SampleableTexture3D* This) { delete This; }

void SampleableTextureCube_Destroy(SampleableTextureCube* This) { delete This; }

Texture1D* Texture1D_Texture1D(int qualifiers, Type* format, Device* device, uint32_t width, uint32_t mipLevelCount) {
  return new Texture1D(qualifiers, format, device->device, wgpu::TextureDimension::e1D,
                       {width, 1, 1}, mipLevelCount);
}

void Texture1D_Destroy(Texture1D* This) { delete This; }

SampleableTexture1D* Texture1D_CreateSampleableView(Texture1D* This, uint32_t baseMipLevel, uint32_t mipLevelCount) {
  return new SampleableTexture1D(This->CreateView(baseMipLevel, mipLevelCount));
}

Texture1D* Texture1D_CreateStorageView(Texture1D* This, uint32_t mipLevel) {
  return new Texture1D(This, This->CreateView(mipLevel));
}

void Texture1D_CopyFromBuffer(Texture1D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              uint32_t        width,
                              uint32_t        origin,
                              uint32_t        mipLevel) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {width, 1, 1}, {origin, 0, 0}, mipLevel);
}

Texture2D* Texture2D_Texture2D(int qualifiers, Type* format, Device* device, const uint32_t* size, uint32_t mipLevelCount) {
  return new Texture2D(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                       {size[0], size[1], 1}, mipLevelCount);
}

void Texture2D_Destroy(Texture2D* This) { delete This; }

SampleableTexture2D* Texture2D_CreateSampleableView(Texture2D* This, uint32_t baseMipLevel, uint32_t mipLevelCount) {
  return new SampleableTexture2D(This->CreateView(baseMipLevel, mipLevelCount));
}

Texture2D* Texture2D_CreateRenderableView(Texture2D* This, uint32_t mipLevel) {
  return new Texture2D(This, This->Create2DView(mipLevel));
}

Texture2D* Texture2D_CreateStorageView(Texture2D* This, uint32_t mipLevel) {
  return new Texture2D(This, This->CreateView(mipLevel));
}

ColorOutput* Texture2D_CreateColorOutput(Texture2D*   This,
                                         LoadOp       loadOp,
                                         StoreOp      storeOp,
                                         const float* clearValue) {
  wgpu::RenderPassColorAttachment attachment;
  attachment.clearValue = {clearValue[0], clearValue[1], clearValue[2], clearValue[3]};
  attachment.loadOp = ToDawnLoadOp(loadOp);
  attachment.storeOp = ToDawnStoreOp(storeOp);
  attachment.view = This->view;
  return new ColorOutput(attachment);
}

DepthStencilOutput* Texture2D_CreateDepthStencilOutput(Texture2D* This,
                                                               LoadOp     depthLoadOp,
                                                               StoreOp    depthStoreOp,
                                                               float      depthClearValue,
                                                               LoadOp     stencilLoadOp,
                                                               StoreOp    stencilStoreOp,
                                                               int stencilClearValue) {
  wgpu::RenderPassDepthStencilAttachment attachment;
  attachment.view = This->view;
  attachment.depthLoadOp = ToDawnLoadOp(depthLoadOp);
  attachment.depthStoreOp = ToDawnStoreOp(depthStoreOp);
  attachment.depthClearValue = depthClearValue;
  attachment.stencilLoadOp = ToDawnLoadOp(stencilLoadOp);
  attachment.stencilStoreOp = ToDawnStoreOp(stencilStoreOp);
  attachment.stencilClearValue = stencilClearValue;
  return new DepthStencilOutput(attachment);
}

uint32_t Texture2D_MinBufferWidth(Texture2D* This) { return This->MinBufferWidth(); }

void Texture2D_CopyFromBuffer(Texture2D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              const uint32_t* size,
                              const uint32_t* origin,
                              uint32_t        mipLevel) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {size[0], size[1], 1},
                       {origin[0], origin[1], 0}, mipLevel);
}

Texture2DArray* Texture2DArray_Texture2DArray(int             qualifiers,
                                              Type*           format,
                                              Device*         device,
                                              const uint32_t* size,
                                              uint32_t        mipLevelCount) {
  return new Texture2DArray(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                            {size[0], size[1], size[2]}, mipLevelCount);
}

void Texture2DArray_Destroy(Texture2DArray* This) { delete This; }

SampleableTexture2DArray* Texture2DArray_CreateSampleableView(
    Texture2DArray* This, uint32_t baseMipLevel, uint32_t mipLevelCount, uint32_t baseArrayLayer,
    uint32_t arrayLayerCount) {
  return new SampleableTexture2DArray(This->CreateView(baseMipLevel, mipLevelCount,
                                                       baseArrayLayer, arrayLayerCount));
}

Texture2D* Texture2DArray_CreateRenderableView(Texture2DArray* This,
                                               uint32_t        layer,
                                               uint32_t        mipLevel) {
  return new Texture2D(This, This->Create2DView(mipLevel, layer));
}

Texture2DArray* Texture2DArray_CreateStorageView(Texture2DArray* This,
                                                 uint32_t        baseArrayLayer,
                                                 uint32_t        mipLevel) {
  return new Texture2DArray(This, This->CreateView(mipLevel, 0, baseArrayLayer, 0));
}

uint32_t Texture2DArray_MinBufferWidth(Texture2DArray* This) { return This->MinBufferWidth(); }

void Texture2DArray_CopyFromBuffer(Texture2DArray* dest,
                                   CommandEncoder* encoder,
                                   Buffer*         source,
                                   const uint32_t* size,
                                   const uint32_t* origin,
                                   uint32_t        mipLevel) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {size[0], size[1], size[2]},
                       {origin[0], origin[1], origin[2]}, mipLevel);
}

Texture3D* Texture3D_Texture3D(int qualifiers, Type* format, Device* device, const uint32_t* size, uint32_t mipLevelCount) {
  return new Texture3D(qualifiers, format, device->device, wgpu::TextureDimension::e3D,
                       {size[0], size[1], size[2]}, mipLevelCount);
}

void Texture3D_Destroy(Texture3D* This) { delete This; }

SampleableTexture3D* Texture3D_CreateSampleableView(Texture3D* This, uint32_t baseMipLevel, uint32_t mipLevelCount) {
  return new SampleableTexture3D(This->CreateView(baseMipLevel, mipLevelCount));
}

Texture2D* Texture3D_CreateRenderableView(Texture3D* This, uint32_t depth, uint32_t mipLevel) {
  return new Texture2D(This, This->Create2DView(mipLevel, depth));
}

Texture3D* Texture3D_CreateStorageView(Texture2D* This, uint32_t baseDepth, uint32_t mipLevel) {
  return new Texture3D(This, This->CreateView(mipLevel, 0, baseDepth, 0));
}

uint32_t Texture3D_MinBufferWidth(Texture3D* This) { return This->MinBufferWidth(); }

void Texture3D_CopyFromBuffer(Texture3D*      dest,
                              CommandEncoder* encoder,
                              Buffer*         source,
                              const uint32_t* size,
                              const uint32_t* origin,
                              uint32_t        mipLevel) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {size[0], size[1], size[2]},
                       {origin[0], origin[1], origin[2]}, mipLevel);
}

TextureCube* TextureCube_TextureCube(int             qualifiers,
                                     Type*           format,
                                     Device*         device,
                                     const uint32_t* size,
                                     uint32_t        mipLevelCount) {
  return new TextureCube(qualifiers, format, device->device, wgpu::TextureDimension::e2D,
                         {size[0], size[1], 6}, mipLevelCount);
}

void TextureCube_Destroy(TextureCube* This) { delete This; }

SampleableTextureCube* TextureCube_CreateSampleableView(TextureCube* This, uint32_t baseMipLevel, uint32_t mipLevelCount) {
  return new SampleableTextureCube(This->CreateView(baseMipLevel, mipLevelCount));
}

Texture2D* TextureCube_CreateRenderableView(TextureCube* This, int32_t face, int32_t mipLevel) {
  return new Texture2D(This, This->CreateView(mipLevel, face));
}

TextureCube* TextureCube_CreateStorageView(TextureCube* This, int32_t face, int32_t mipLevel) {
  return new TextureCube(This, This->CreateView(mipLevel, 0, face, 0));
}

uint32_t TextureCube_MinBufferWidth(TextureCube* This) { return This->MinBufferWidth(); }

void TextureCube_CopyFromBuffer(TextureCube*    dest,
                                CommandEncoder* encoder,
                                Buffer*         source,
                                const uint32_t* size,
                                const uint32_t* origin,
                                uint32_t        mipLevel) {
  dest->CopyFromBuffer(encoder->encoder, source->buffer, {size[0], size[1], size[2]},
                       {origin[0], origin[1], origin[2]}, mipLevel);
}

Sampler* Sampler_Sampler(Device*     device,
                         AddressMode addressModeU,
                         AddressMode addressModeV,
                         AddressMode addressModeW,
                         FilterMode  magFilter,
                         FilterMode  minFilter,
                         FilterMode  mipmapFilter) {
  wgpu::SamplerDescriptor desc;
  desc.addressModeU = ToDawnAddressMode(addressModeU);
  desc.addressModeV = ToDawnAddressMode(addressModeV);
  desc.addressModeW = ToDawnAddressMode(addressModeW);
  desc.magFilter = ToDawnFilterMode(magFilter);
  desc.minFilter = ToDawnFilterMode(minFilter);
  desc.mipmapFilter = ToDawnMipmapFilterMode(mipmapFilter);
  wgpu::Sampler sampler = device->device.CreateSampler(&desc);
  return new Sampler(sampler);
}

void Sampler_Destroy(Sampler* This) { delete This; }

void Buffer_CopyFromBuffer(Buffer* This, CommandEncoder* encoder, Buffer* source) {
  encoder->encoder.CopyBufferToBuffer(source->buffer, 0, This->buffer, 0, source->sizeInBytes);
}

static Object* MapSync(wgpu::MapMode mapMode, Buffer* buffer) {
  if (buffer->buffer.GetMapState() == wgpu::BufferMapState::Mapped) {
    buffer->mappedObject.controlBlock->weakRefs++;
    buffer->mappedObject.controlBlock->strongRefs++;
    return &buffer->mappedObject;
  }

  wgpu::MapAsyncStatus mapStatus = wgpu::MapAsyncStatus::Error;
  wgpu::Future future = buffer->buffer.MapAsync(mapMode, 0, buffer->sizeInBytes, wgpu::CallbackMode::WaitAnyOnly,
                                                [&mapStatus](wgpu::MapAsyncStatus s, wgpu::StringView) {
                                                  mapStatus = s;
                                                });
  wgpu::FutureWaitInfo waitInfo = {future};
  if (gInstance.WaitAny(1, &waitInfo, UINT64_MAX) != wgpu::WaitStatus::Success
      || mapStatus != wgpu::MapAsyncStatus::Success) {
    return &buffer->mappedObject;
  }

  Object result;
  if (!(mapMode & wgpu::MapMode::Write)) {
    const void* ptr = buffer->buffer.GetConstMappedRange();
    buffer->mappedObject.ptr = const_cast<void*>(ptr);
  } else {
    buffer->mappedObject.ptr = buffer->buffer.GetMappedRange();
  }
#if TARGET_OS_IS_WIN && TARGET_CPU_IS_X86
  ControlBlock* controlBlock =
      static_cast<ControlBlock*>(_aligned_malloc(sizeof(ControlBlock), 16));
#else
  ControlBlock* controlBlock = static_cast<ControlBlock*>(malloc(sizeof(ControlBlock)));
#endif
  controlBlock->strongRefs = 1;
  controlBlock->weakRefs = 1;
  controlBlock->type = buffer->type;
  controlBlock->arrayLength = buffer->length;
  controlBlock->type = buffer->type;
  controlBlock->deleter = &UnmapBuffer;
  buffer->mappedObject.controlBlock = controlBlock;
  gMappedBuffers[buffer->mappedObject.ptr] = buffer->buffer;
  return &buffer->mappedObject;
}

Buffer* Buffer_Buffer_Device_uint(int      qualifiers,
                                  Type*    type,
                                  Device*  device,
                                  uint32_t dynamicArraySize) {
  wgpu::BufferDescriptor desc;
  desc.usage = toDawnBufferUsage(qualifiers);
  desc.size = type->GetSizeInBytes(dynamicArraySize);
  wgpu::Buffer b = device->device.CreateBuffer(&desc);
  return new Buffer(device->device, b, dynamicArraySize, desc.size, type);
}

Buffer* Buffer_Buffer_Device_T(int qualifiers, Type* type, Device* device, void* data) {
  uint32_t length = 1;
  if (type->IsUnsizedArray()) { length = static_cast<Array*>(data)->length; }
  Buffer* result = Buffer_Buffer_Device_uint(qualifiers, type, device, length);
  Buffer_SetData(result, data);
  return result;
}

Object* Buffer_MapRead_hostreadable_Buffer(Buffer* buffer) { return MapSync(wgpu::MapMode::Read, buffer); }

Object* Buffer_MapWrite_hostwriteable_Buffer(Buffer* buffer) { return MapSync(wgpu::MapMode::Write, buffer); }

void Buffer_SetData(Buffer* buffer, void* data) {
  Type* type = buffer->type;
  assert(!type->IsPtr());
  uint32_t    length = 1;
  if (type->IsUnsizedArray()) {
    Array* array = static_cast<Array*>(data);
    length = array->length;
    data = array->ptr;
  }
  wgpu::Queue queue = buffer->device.GetQueue();
  queue.WriteBuffer(buffer->buffer, 0, data, type->GetSizeInBytes(length));
}

void Buffer_Destroy(Buffer* This) { delete This; }

CommandEncoder* CommandEncoder_CommandEncoder(Device* device) {
  wgpu::CommandEncoderDescriptor desc;
  return new CommandEncoder(device->device.CreateCommandEncoder(&desc));
}

void CommandEncoder_Destroy(CommandEncoder* This) { delete This; }

void Queue_Submit(Queue* queue, CommandBuffer* commandBuffer) {
  queue->queue.Submit(1, &commandBuffer->commandBuffer);
}

VertexInput* VertexInput_VertexInput(int     qualifiers,
                                     Type*   type,
                                     Buffer* buffer) {
  return new VertexInput(buffer->buffer);
}

void VertexInput_Destroy(VertexInput* This) { delete This; }

void ColorOutput_Destroy(ColorOutput* This) { delete This; }

void DepthStencilOutput_Destroy(DepthStencilOutput* This) { delete This; }

RenderPass* RenderPass_RenderPass_CommandEncoder_T(int             qualifiers,
                                                   Type*           type,
                                                   CommandEncoder* encoder,
                                                   void*           data) {
  PipelineData pipelineData;
  ExtractPipelineData(type, data, &pipelineData);

  wgpu::RenderPassDescriptor desc;
  desc.colorAttachmentCount = pipelineData.colorAttachments.size();
  desc.colorAttachments = pipelineData.colorAttachments.data();
  if (pipelineData.depthStencilAttachment.view != nullptr) {
    desc.depthStencilAttachment = &pipelineData.depthStencilAttachment;
  }
  auto result = encoder->encoder.BeginRenderPass(&desc);
  pipelineData.Set(result);
  return new RenderPass(result, type);
}

RenderPass* RenderPass_RenderPass_RenderPass(int qualifiers, Type* type, RenderPass* parent) {
  return new RenderPass(parent->encoder, type);
}

void RenderPass_Set(RenderPass* This, void* data) {
  PipelineData pipelineData;
  ExtractPipelineData(This->type, data, &pipelineData);
  pipelineData.Set(This->encoder);
}

void RenderPass_SetPipeline(RenderPass* This, RenderPipeline* pipeline) {
  This->encoder.SetPipeline(pipeline->pipeline);
}

void RenderPass_Draw(RenderPass* This,
                     uint32_t    vertexCount,
                     uint32_t    instanceCount,
                     uint32_t    firstVertex,
                     uint32_t    firstInstance) {
  This->encoder.Draw(vertexCount, instanceCount, firstVertex, firstInstance);
}

void RenderPass_DrawIndexed(RenderPass* This,
                            uint32_t    indexCount,
                            uint32_t    instanceCount,
                            uint32_t    firstVertex,
                            uint32_t    baseVertex,
                            uint32_t    firstInstance) {
  This->encoder.DrawIndexed(indexCount, instanceCount, firstVertex, baseVertex, firstInstance);
}

void RenderPass_End(RenderPass* This) { This->encoder.End(); }

void RenderPass_Destroy(RenderPass* This) { delete This; }

ComputePass* ComputePass_ComputePass_CommandEncoder_T(int             qualifiers,
                                                      Type*           type,
                                                      CommandEncoder* encoder,
                                                      void*           data) {
  PipelineData pipelineData;
  ExtractPipelineData(type, data, &pipelineData);
  wgpu::ComputePassDescriptor desc;
  auto                        passEncoder = encoder->encoder.BeginComputePass(&desc);
  pipelineData.Set(passEncoder);
  return new ComputePass(passEncoder, type);
}

ComputePass* ComputePass_ComputePass_ComputePass(int qualifiers, Type* type, ComputePass* parent) {
  assert(type->IsClass());
  return new ComputePass(parent->encoder, static_cast<ClassType*>(type));
}

void ComputePass_SetPipeline(ComputePass* This, ComputePipeline* pipeline) {
  This->encoder.SetPipeline(pipeline->pipeline);
}

void ComputePass_Set(ComputePass* This, void* data) {
  PipelineData pipelineData;
  ExtractPipelineData(This->type, data, &pipelineData);
  pipelineData.Set(This->encoder);
}

void ComputePass_Dispatch(ComputePass* This,
                          uint32_t     workgroupCountX,
                          uint32_t     workgroupCountY,
                          uint32_t     workgroupCountZ) {
  This->encoder.DispatchWorkgroups(workgroupCountX, workgroupCountY, workgroupCountZ);
}

void ComputePass_End(ComputePass* This) { This->encoder.End(); }

void ComputePass_Destroy(ComputePass* This) { delete This; }

CommandBuffer* CommandEncoder_Finish(CommandEncoder* encoder) {
  return new CommandBuffer(encoder->encoder.Finish());
}

void CommandBuffer_Destroy(CommandBuffer* This) { delete This; }

Texture2D* SwapChain_GetCurrentTexture(SwapChain* swapChain) {
  wgpu::SurfaceTexture surfaceTexture;
  swapChain->surface.GetCurrentTexture(&surfaceTexture);
  wgpu::Texture texture = surfaceTexture.texture;

  return new Texture2D(texture, texture.CreateView());
}

#if !TARGET_OS_IS_MAC && !TARGET_OS_IS_IOS
#if !TARGET_OS_IS_WASM
void SwapChain_Present(SwapChain* swapChain) { swapChain->surface.Present(); }
#endif

void SwapChain_Destroy(SwapChain* This) { delete This; }
#endif

void SwapChain_Resize(SwapChain* swapChain, const uint32_t* size) {
  wgpu::SurfaceConfiguration config;
  config.device = swapChain->device;
  config.format = swapChain->format;
  config.width = size[0];
  config.height = size[1];
  config.presentMode = wgpu::PresentMode::Fifo;

  swapChain->surface.Configure(&config);
  swapChain->extent = {size[0], size[1], 1};
}

float Math_rand() { return (float)(rand() % 100) / 100.0f; }

void Math_Destroy(Math* This) {}

#if !TARGET_OS_IS_IOS
void System_Print(Array* buffer) {
  fwrite(buffer->ptr, 1, buffer->length, stdout);
}

void System_PrintLine(Array* buffer) {
  fwrite(buffer->ptr, 1, buffer->length, stdout);
  fwrite("\n", 1, 1, stdout);
}
#endif

void System_Abort() {
  printf("  Y__Y\n");
  printf("--\\__(x)==     (pining for the fjords)\n");
  if (exitOnAbort) {
    exit(1);
  } else {
    abort();
  }
}

void System_Destroy(System* This) {}

void Event_Destroy(Event* This) { delete This; }

wgpu::Device CreateDawnDevice(wgpu::BackendType type, const wgpu::DeviceDescriptor* desc) {
  if (!gInstance) {
#if !TARGET_OS_IS_WASM
    DawnProcTable backendProcs = dawn::native::GetProcs();
    dawnProcSetProcs(&backendProcs);
#endif
    wgpu::InstanceDescriptor instanceDesc;
    instanceDesc.capabilities.timedWaitAnyEnable = true;
    gInstance = wgpu::CreateInstance(&instanceDesc);
  }

  wgpu::Adapter adapter;
  wgpu::RequestAdapterOptions adapterOptions;
  adapterOptions.backendType = type;
  auto adapterFuture = gInstance.RequestAdapter(&adapterOptions, wgpu::CallbackMode::WaitAnyOnly,
      [&adapter](wgpu::RequestAdapterStatus status, wgpu::Adapter a, const char *msg) {
    adapter = a;
  });
  wgpu::FutureWaitInfo aWaitInfo = { adapterFuture };
  if (gInstance.WaitAny(1, &aWaitInfo, UINT64_MAX) != wgpu::WaitStatus::Success) { return nullptr; }
  if (!adapter) return nullptr;

  wgpu::Device device;
  auto deviceFuture = adapter.RequestDevice(desc, wgpu::CallbackMode::WaitAnyOnly,
      [&device](wgpu::RequestDeviceStatus status, wgpu::Device d, const char* msg) {
    device = d;
  });
  wgpu::FutureWaitInfo dWaitInfo = { deviceFuture };
  if (gInstance.WaitAny(1, &dWaitInfo, UINT64_MAX) != wgpu::WaitStatus::Success) { return nullptr; }
  return device;
}

};  // namespace Toucan
