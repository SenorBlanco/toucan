// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <sys/timeb.h>
#include <windows.h>

#include <memory>

#include <webgpu/webgpu_cpp.h>

#include "api_internal.h"

namespace Toucan {

namespace {

void PrintDeviceError(WGPUErrorType, const char* message, void*) { OutputDebugString(message); }

unsigned ToToucanEventModifiers(WPARAM wParam) {
  unsigned result = 0;

  if (wParam & MK_SHIFT) { result |= Shift; }
  if (wParam & MK_CONTROL) { result |= Control; }
  return result;
}

}  // namespace

struct Window {
  Window(HWND w, Device* d, wgpu::Surface s) : wnd(w), device(d), surface(s) {}
  HWND          wnd;
  wgpu::Surface surface;
  Device*       device;
};

static int                                     gNumWindows = 0;

static LRESULT CALLBACK mainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
  LONG rc = 0L;

  switch (message) {
    case WM_CLOSE:
      ::DestroyWindow(hWnd);
      if (--gNumWindows == 0) { ::PostQuitMessage(0); }
      break;
    default: rc = DefWindowProc(hWnd, message, wParam, lParam); break;
  }
  return rc;
}

static void registerMainWindowClass() {
  static bool registered = false;
  if (!registered) {
    WNDCLASS wc;
    wc.lpszClassName = "mainWndClass";
    wc.lpfnWndProc = mainWndProc;
    wc.style = CS_OWNDC | CS_VREDRAW | CS_HREDRAW;
    wc.hInstance = nullptr;
    wc.hIcon = ::LoadIcon(nullptr, IDI_APPLICATION);
    wc.hCursor = ::LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = ::GetSysColorBrush(COLOR_WINDOW);
    wc.lpszMenuName = "mainMenu";
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;

    RegisterClass(&wc);
    registered = true;
  }
}

Window* Window_Window(Device* device, int32_t x, int32_t y, uint32_t width, uint32_t height) {
  registerMainWindowClass();
  RECT  r = {0, 0, static_cast<LONG>(width), static_cast<LONG>(height)};
  DWORD style = WS_OVERLAPPEDWINDOW;
  bool  hasMenuBar = false;
  ::AdjustWindowRect(&r, style, hasMenuBar);
  HWND hwnd = ::CreateWindow("mainWndClass", "Main Window", style, x, y, r.right - r.left,
                             r.bottom - r.top, nullptr, nullptr, nullptr, nullptr);
  if (!hwnd) return nullptr;

  ::ShowWindow(hwnd, SW_SHOW);

  wgpu::SurfaceDescriptorFromWindowsHWND winSurfaceDesc;
  winSurfaceDesc.hwnd = hwnd;
  wgpu::SurfaceDescriptor surfaceDesc;
  surfaceDesc.nextInChain = &winSurfaceDesc;

  static wgpu::Instance instance = wgpu::CreateInstance({});
  wgpu::Surface surface = instance.CreateSurface(&surfaceDesc);

  Window*       w = new Window(hwnd, device, surface);
  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)w);
  gNumWindows++;
  return w;
}

void Window_Destroy(Window* This) { delete This; }

Device* Device_Device() {
  wgpu::Device device = CreateDawnDevice(wgpu::BackendType::D3D12, PrintDeviceError);
  if (!device) { return nullptr; }
  return new Device(device);
}

wgpu::TextureFormat GetPreferredSwapChainFormat() { return wgpu::TextureFormat::BGRA8Unorm; }

SwapChain* SwapChain_SwapChain(int qualifiers, Type* format, Window* window) {
  RECT rect;
  GetClientRect(window->wnd, &rect);

  wgpu::SwapChainDescriptor desc;
  desc.usage = wgpu::TextureUsage::RenderAttachment;
  desc.format = ToDawnTextureFormat(format);
  desc.width = rect.right - rect.left;
  desc.height = rect.bottom - rect.top;
  desc.presentMode = wgpu::PresentMode::Fifo;
  wgpu::SwapChain swapChain = window->device->device.CreateSwapChain(window->surface, &desc);
  return new SwapChain(swapChain, {desc.width, desc.height, 1}, desc.format, nullptr);
}

bool System_IsRunning() { return gNumWindows > 0; }

bool System_HasPendingEvents() {
  MSG msg;
  return ::PeekMessage(&msg, nullptr, 0, 0, PM_NOREMOVE) == TRUE;
}

Event* System_GetNextEvent() {
  Event* event = new Event();
  event->type = EventType::Unknown;
  MSG msg;
  GetMessage(&msg, nullptr, 0, 0);
  TranslateMessage(&msg);
  DispatchMessage(&msg);

  LONG rc = 0L;
  event->mousePos[0] = LOWORD(msg.lParam);
  event->mousePos[1] = HIWORD(msg.lParam);
  event->modifiers = ToToucanEventModifiers(msg.wParam);
  event->button = 0;
  switch (msg.message) {
    case WM_LBUTTONDOWN:
      event->button = 0;
      event->type = EventType::MouseDown;
      break;
    case WM_LBUTTONUP:
      event->button = 0;
      event->type = EventType::MouseUp;
      break;
    case WM_RBUTTONDOWN:
      event->button = 2;
      event->type = EventType::MouseDown;
      break;
    case WM_RBUTTONUP:
      event->button = 2;
      event->type = EventType::MouseUp;
      break;
    case WM_MOUSEMOVE: event->type = EventType::MouseMove; break;
    case WM_QUIT: gNumWindows = 0; break;
    default: break;
  }
  return event;
}

double System_GetCurrentTime() {
  struct _timeb t;
  _ftime(&t);
  return static_cast<double>(t.time) + t.millitm / 1000.0;
}

};  // namespace Toucan
