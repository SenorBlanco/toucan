// Copyright 2023 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <sys/time.h>

#include <memory>

#include <dawn/dawn_proc.h>
#include <dawn/native/DawnNative.h>
#include <webgpu/webgpu_cpp.h>

#import <AppKit/AppKit.h>
#import <Metal/Metal.h>
#import <QuartzCore/CAMetalLayer.h>

#include "api_internal.h"

@interface ToucanWindowDelegate : NSObject {
  Toucan::Window* window;
}
- (instancetype)initWithWindow:(Toucan::Window*)w;
@end

@interface ToucanAppDelegate : NSObject <NSApplicationDelegate>
@end

static bool gIsRunning = true;

namespace Toucan {

namespace {
void PrintDeviceError(WGPUErrorType, const char* message, void*) {
  printf("Device error: %s\n", message);
}

}  // namespace

static std::unique_ptr<dawn::native::Instance> gNativeInstance;
static wgpu::Instance                          gInstance;
static bool                                    gInitialized = false;

struct Window {
  Window(NSWindow*     nsw,
         NSView*       v,
         CAMetalLayer* l,
         id<MTLDevice> md,
         wgpu::Surface s,
         Device*       d,
         uint32_t      w,
         uint32_t      h)
      : window(nsw), view(v), layer(l), mtlDevice(md), surface(s), device(d), width(w), height(h) {}
  NSWindow*     window;
  NSView*       view;
  CAMetalLayer* layer;
  id<MTLDevice> mtlDevice;
  wgpu::Surface surface;
  Device*       device;
  uint32_t      width;
  uint32_t      height;
};

namespace {

unsigned ToToucanEventModifiers(NSEventModifierFlags modifiers) {
  unsigned result = 0;
  if (modifiers & NSEventModifierFlagShift) { result |= Shift; }
  if (modifiers & NSEventModifierFlagControl) { result |= Control; }
  return result;
}

void Initialize() {
  NSApplication* app = [NSApplication sharedApplication];
  [app setActivationPolicy:NSApplicationActivationPolicyRegular];

  NSMenu* menuBar = [[NSMenu alloc] init];
  [NSApp setMainMenu:menuBar];

  NSMenuItem* menu = [[NSMenuItem alloc] init];
  [menuBar addItem:menu];

  NSMenu* subMenu = [[NSMenu alloc] init];
  [menuBar setSubmenu:subMenu forItem:menu];
  [menu release];

  NSMenuItem* item = [[NSMenuItem alloc] initWithTitle:@"Quit"
                                                action:@selector(terminate:)
                                         keyEquivalent:@"q"];
  [subMenu addItem:item];
  [item release];
  [subMenu release];
  [menuBar release];

  ToucanAppDelegate* delegate = [[ToucanAppDelegate alloc] init];
  [NSApp setDelegate:delegate];

  if (![[NSRunningApplication currentApplication] isFinishedLaunching]) { [NSApp run]; }
}

// FIXME: refactor this, and make instance persistent
wgpu::Device createDevice(wgpu::BackendType type) {
  if (!gNativeInstance) {
    gNativeInstance = std::make_unique<dawn::native::Instance>();
    DawnProcTable backendProcs = dawn::native::GetProcs();
    dawnProcSetProcs(&backendProcs);
  }

  if (!gInstance) {
    wgpu::InstanceDescriptor desc;
    gInstance = wgpu::CreateInstance(&desc);
  }

  for (auto adapter : gNativeInstance->EnumerateAdapters()) {
    wgpu::AdapterProperties properties;
    adapter.GetProperties(&properties);
    if (properties.backendType == type) { return adapter.CreateDevice(); }
  }
  return nullptr;
}

}  // namespace

Window* Window_Window(Device* device, int32_t x, int32_t y, uint32_t width, uint32_t height) {
  NSApplication* app = [NSApplication sharedApplication];
  NSRect         rect = NSMakeRect(x, y, width, height);
  int mask = NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskMiniaturizable |
             NSWindowStyleMaskResizable;
  NSWindow* window = [[NSWindow alloc] initWithContentRect:rect
                                                 styleMask:mask
                                                   backing:NSBackingStoreBuffered
                                                     defer:NO];
  [window setAcceptsMouseMovedEvents:YES];
  // FIXME: we assume Dawn is using the system default device.
  // this could be wrong on multi-GPU systems.
  id<MTLDevice> mtlDevice = MTLCreateSystemDefaultDevice();

  CGSize size;
  size.width = width;
  size.height = height;
  [window makeKeyAndOrderFront:NSApp];

  CAMetalLayer* layer = [CAMetalLayer layer];
  [layer setDevice:mtlDevice];
  [layer setPixelFormat:MTLPixelFormatBGRA8Unorm];
  [layer setFramebufferOnly:YES];
  [layer setDrawableSize:size];
  [layer setColorspace:CGColorSpaceCreateDeviceRGB()];

  NSView* view = [[NSView alloc] initWithFrame:rect];
  [view setWantsLayer:YES];
  [view setLayer:layer];

  [window setContentView:view];
  wgpu::SurfaceDescriptorFromMetalLayer metalLayerDesc;
  metalLayerDesc.layer = layer;
  wgpu::SurfaceDescriptor desc;
  desc.nextInChain = &metalLayerDesc;
  wgpu::Surface surface = gInstance.CreateSurface(&desc);
  Window*       w = new Window(window, view, layer, mtlDevice, surface, device, width, height);
  id            delegate = [[ToucanWindowDelegate alloc] initWithWindow:w];
  [window setDelegate:delegate];
  return w;
}

void Window_Destroy(Window* This) { delete This; }

SwapChain* SwapChain_SwapChain(Window* window) {
  wgpu::SwapChainDescriptor desc;
  // FIXME: convert passed-in format, add usage and present mode
  desc.usage = wgpu::TextureUsage::RenderAttachment;
  desc.format = wgpu::TextureFormat::BGRA8Unorm;
  desc.width = window->width;
  desc.height = window->height;
  desc.presentMode = wgpu::PresentMode::Fifo;
  wgpu::SwapChain swapChain = window->device->device.CreateSwapChain(window->surface, &desc);

  return new SwapChain(swapChain, [[NSAutoreleasePool alloc] init]);
}

void SwapChain_Present(SwapChain* swapChain) {
  swapChain->swapChain.Present();
  [static_cast<NSAutoreleasePool*>(swapChain->pool) release];
  swapChain->pool = [[NSAutoreleasePool alloc] init];
}

void SwapChain_Destroy(SwapChain* This) {
  [static_cast<NSAutoreleasePool*>(This->pool) release];
  delete This;
}

Device* Device_Device() {
  static std::unique_ptr<dawn::native::Instance> instance =
      std::make_unique<dawn::native::Instance>();
  wgpu::Device device = createDevice(wgpu::BackendType::Metal);
  if (!device) { return nullptr; }
  device.SetUncapturedErrorCallback(PrintDeviceError, nullptr);
  return new Device(device);
}

bool System_IsRunning() { return gIsRunning; }

bool System_HasPendingEvents() {
  NSApplication* app = [NSApplication sharedApplication];
  NSEvent*       nsEvent = [app nextEventMatchingMask:NSEventMaskAny
                                      untilDate:nil
                                         inMode:NSDefaultRunLoopMode
                                        dequeue:NO];
  return nsEvent != nullptr;
}

Event* System_GetNextEvent() {
  if (!gInitialized) {
    Initialize();
    gInitialized = true;
  }
  NSApplication* app = [NSApplication sharedApplication];
  NSEvent*       nsEvent = [app nextEventMatchingMask:NSEventMaskAny
                                      untilDate:[NSDate distantFuture]
                                         inMode:NSDefaultRunLoopMode
                                        dequeue:YES];
  [NSApp sendEvent:nsEvent];
  Event* event = new Event();
  int    height = [[nsEvent.window contentView] frame].size.height;
  event->mousePos[0] = nsEvent.locationInWindow.x;
  event->mousePos[1] = height - nsEvent.locationInWindow.y;
  event->modifiers = ToToucanEventModifiers(nsEvent.modifierFlags);
  event->button = 0;
  event->type = EventType::Unknown;

  switch (nsEvent.type) {
    case NSEventTypeLeftMouseDown:
      event->type = EventType::MouseDown;
      event->button = 0;
      break;
    case NSEventTypeRightMouseDown:
      event->type = EventType::MouseDown;
      event->button = 2;
      break;
    case NSEventTypeMouseEntered: break;
    case NSEventTypeMouseExited: break;
    case NSEventTypeLeftMouseUp:
      event->type = EventType::MouseUp;
      event->button = 0;
      break;
    case NSEventTypeRightMouseUp:
      event->type = EventType::MouseUp;
      event->button = 2;
      break;
    case NSEventTypeOtherMouseDown:
      event->type = EventType::MouseDown;
      event->button = 1;
      break;
    case NSEventTypeOtherMouseUp:
      event->type = EventType::MouseUp;
      event->button = 1;
      break;
    case NSEventTypeKeyDown: break;
    case NSEventTypeKeyUp: break;
    case NSEventTypeMouseMoved:
    case NSEventTypeLeftMouseDragged:
    case NSEventTypeRightMouseDragged:
      if (nsEvent.window) { event->type = EventType::MouseMove; }
      break;
    case NSEventTypeAppKitDefined:
      switch ([nsEvent subtype]) {
        case NSEventSubtypeWindowExposed: break;
        case NSEventSubtypeApplicationActivated: break;
        case NSEventSubtypeScreenChanged: break;
        case NSEventSubtypeWindowMoved: break;
        default: break;
      }
      break;
    case NSEventTypeApplicationDefined: break;
    case NSEventTypeCursorUpdate: break;
    case NSEventTypeSystemDefined: break;
    case NSEventTypeFlagsChanged: break;
    case NSEventTypePeriodic: break;
    case NSEventTypeQuickLook: break;
    default: event->type = EventType::Unknown;
  }
  return event;
}

double System_GetCurrentTime() {
  struct timeval now;

  gettimeofday(&now, NULL);
  return static_cast<double>(now.tv_sec) + static_cast<double>(now.tv_usec) / 1000000.0;
}

void Window_SwapBuffers(Window* window) {
  if (!window || !window->device) return;
  //  [window->device->device flushBuffer]; // FIXME
}

};  // namespace Toucan

@implementation ToucanWindowDelegate
- (instancetype)initWithWindow:(Toucan::Window*)w {
  self = [super init];
  if (self != nil) window = w;

  return self;
}

- (BOOL)windowShouldClose:(id)sender {
  return YES;
}

- (void)windowDidResize:(NSNotification*)notification {
  const NSRect contentRect = [window->view frame];
  const NSRect fbRect = [window->view convertRectToBacking:contentRect];

  if (fbRect.size.width != window->width || fbRect.size.height != window->height) {
    window->width = fbRect.size.width;
    window->height = fbRect.size.height;

    // FIXME: send a resize event
  }
}
@end

@implementation ToucanAppDelegate : NSObject
- (id)init {
  self = [super init];
  gIsRunning = true;
  return self;
}

- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication*)sender {
  gIsRunning = false;
  return NSTerminateCancel;
}

- (void)applicationDidFinishLaunching:(NSNotification*)notification {
  [NSApp stop:nil];
}
@end
