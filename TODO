- implement window resize event
- implement foreach
- implement Math.inverse() on CPU side
- implement bounds checking
- use O1 optimization in TC
- implement Math fns, e.g. dot()
- implement parsing of a method call without .
- finish storage textures
- refactor tc & tj
- change length attribute to builtin function
- fix LLVM codegen of chained array access
- implement "constant" keyword
- validate return values in semantic pass
- implement "using" of a class (for static methods)
- constify all Visitor arguments and Accept() functions?
- all pointers are implicitly readonly in shader code?
- autogenerate actual SPIR-V functions for pass-through methods? e.g., MapRead()
- remove AutoType in favour of parse-time checking?
- ensure index/vertex/uniform/storage qualifiers are only applied to Buffer
- decide on Vector vs List naming: VarVector? or VarList?
- implement "Is<>" and "As<>"
- write shader validation pass
 - check bind group contents: non-empty (to satisfy WGSL)
 - all classes other than bind groups must be POD
 - no virtual functions
 - no allocation
 - no pointers other than Buffer, Texture*, TextureView*
 - no conditional assignment to pointer variables
- convert bindings generator from C to C++
- texture formats
- prevent calls into null via native methods in api.t that don't exist
- implement long, ulong
- Make ClassTemplate take a vector of TemplateTypes, not just Type*
  - or maybe just a vector of std::string?
- do parameter translation on API entry, exit
  - create wrapper objects in API constructors, creators
- finish destructors
- implement narrowing class casts
- call field initializers
- use shared_ptr in scope->method?  (just in case the parser blows up before
  the method parse completes)
- clean up scope stuff:
  - make scopes optional, and remove all strings from AST?
- Var's outside of VarVectors and stmts probably leaking (e.g., classes, methods)
- better error message for failed method match
